{"id":"1569558901","paper":{"title":{"text":"Snake-in-the-Box Codes for Rank Modulation"},"authors":[{"name":"Yonatan Yehezkeally"},{"name":"Moshe Schwartz"}],"abstr":{"text":"Abstract\u2014Motivated by the rank-modulation scheme with applications to ﬂash memory, we consider Gray codes capable of detecting a single error, also known as snake-in-the-box codes. We study two error metrics: Kendall\u2019s τ-metric, which applies to charge-constrained errors, and the ∞ -metric, which is useful in the case of limited-magnitude errors. In both cases we construct snake-in-the-box codes with rate asymptotically tending to 1.\nIndex Terms\u2014Snake-in-the-box codes, rank modulation, per- mutations, ﬂash memory"},"body":{"text":"Flash memory is a non-volatile storage medium which is electrically programmable and erasable. Its current wide use is motivated by its high storage density and relative low cost. Among the chief disadvantages of ﬂash memories is their inherent asymmetry between cell programming (injecting cells with charge) and cell erasure (removing charge from cells). While single cells can be programmed with relative ease, in the current architecture, the process of erasure can only be performed by completely depleting large blocks of cells of their charge. Moreover, the removal of charge from cells physically damages them over time.\nThis issue is exacerbated as a result of the ever-present demand for denser memory: smaller cells are more delicate, and are damaged faster during erasure. They also contain less charge and are therefore more prone to error. In addition, ﬂash memories, at present, use multilevel cells, where charge-levels are quantized to simulate a ﬁnite alphabet \u2013 the more levels, the less safety margins are left, and data integrity is compro- mised. Thus, over-programming (increasing a cell\u2019s charge- level above the designated mark) is a real problem, requiring a costly and damaging erasure cycle. Hence, in a programming cycle, charge-levels are usually made to gradually approach the desirable amount, making for lengthier programming cycles as well (see [3]).\nIn an effort to counter these effects, a different modulation scheme has recently been suggested for ﬂash memories \u2013 rank modulation [11]. This scheme calls for the representation of the data stored in a group of cells in the permutation suggested by their relative charge-levels. That is, if c 1 , c 2 , . . . , c n ∈ R represent the charge-levels of n ∈ N cells, then that group of cells is said to encode that permutation σ ∈ S n such that:\nThis scheme eliminates the need for discretization of charge- levels. In addition, rank modulation also improves the mem- ory\u2019s robustness against other noise types. Retention, the process of slow charge leakage from cells, tends to affect all cells with a similar trend [3]. Since rank modulation stores information in the differences between charge-levels rather than their absolute values, it offers more resilience against that type of noise. It is also worth noting that the advantages of rank modulation have been experimentally applied to phase- change memory with promising results (see [16]).\nThe Gray code [8] was ﬁrst introduced as a sequence of distinct binary vectors of ﬁxed length, where every adjacent pair differs in a single coordinate. It has since been gener- alized to sequences of states over other spaces, where each state is derived from the former by a transformation from a predetermined set of allowed transformations (see [17] for an excellent survey). Among these, [11] studied Gray odes over permutations, and presented such codes traversing the entire group of permutations. In this fashion, it was suggested that a set of n rank-modulation cells could implement a single logical multilevel cell with n! levels, where increasing the logical cell\u2019s level by 1 corresponds to a single transition in the code. This allows for a natural integration of rank modulation with other multilevel approaches such as rewriting schemes [4], [9], [10], [21]. This was done by restricting the allowed transformations to \u201cpush-to-the-top\u201d operations, namely only programming a group of cells by increasing the charge-level of a single cell above that of all other cells in the group. The use of such Gray codes allows for faster cell programming and eliminates overshoot problems (see [11]). In the context of ﬂash memory, \u201cpush-to-the-top\u201d operations have also been used in [6], [7]. We also note that generating permutations using \u201cpush-to-the-top\u201d operations is of independent interest, called \u201cnested cycling\u201d in [18] (see also references therein), motivated by a fast \u201cpush-to-the-top\u201d operation 1 (cycling) available on some computer architectures.\nOther recent works have explored error-correcting codes for rank modulation, where different types of errors are addressed by a careful choice of metric. In [2], [12], [15], Kendall\u2019s τ- metric was considered, since a small charge-constrained error\ntranslates into a small distance in the metric. In contrast, the ∞ -metric was used in [14], [19], as small distances in this\nIn this paper, we explore Gray codes for rank modulation which detect a single error, under Kendall\u2019s τ-metric (further results in the ∞ -metric are mentioned in the conclusion to this paper). Such codes are known as snake-in-the-box codes, and have been studied extensively for binary vectors with the Hamming metric and with single-bit ﬂips as allowable transitions (see [1] and references therein).\nThe paper is organized as follows: In Section II we present basic notation and deﬁnitions. In Section III we review prop- erties of Kendall\u2019s τ-metric, then present a recursive construc- tion of snake-in-the-box codes over the alternating groups of odd orders with rate asymptotically tending to 1. We conclude in Section IV with a description of further results given without proof, along with some ad-hoc results, and open questions. Some proofs for stated results are omitted due to the limited space; they can be found in the journal version of this work, to appear in [22].\nWe shall denote a permutation σ on n elements by σ = [ σ ( 1 ) , σ ( 2 ) , . . . , σ ( n )] . This form is called the vector notation for permutations. We let S n be the group of all permutations on [ n ] . For σ , τ ∈ S n , their composition, denoted στ, is the permutation for which στ ( i ) = σ ( τ ( i )) for all i ∈ [ n ] . It is well known that | S n | = n!.\nA cycle, denoted ( a 1 , a 2 , . . . , a k ) , is a permutation mapping a i → a i+1 for all i ∈ [ k − 1 ] , as well as a k → a 1 . We shall occasionally use cycle notation in which a permutation is described as a composition of cycles. We also recall that any permutation may be represented as a composition of cycles of size 2 (known as transpositions), and that the parity of the number of transpositions does not depend on the decomposition. Thus we have even and odd permutations. We let A n be the subgroup of all even permutations on [ n ] , called the alternating group of order n. Again, it is well known that\nDeﬁnition 1. Given a set S and a subset of transformations T ⊆ { f | f : S → S } , a Gray code over S, using transitions T, of size M, is a sequence C = ( c 0 , c 1 , . . . , c M−1 ) of M distinct elements of S, called codewords, such that for all j ∈ [ M − 1 ] there exists t ∈ T such that c j = t ( c j−1 ) .\nAlternatively, when the original permutation c 0 is known (or irrelevant), we use a slight abuse of notation in referring to the sequence of transformations ( t k 1 , . . . , t k M − 1 ) generating the code (i.e., c j = t k j ( c j−1 ) ) as the code itself.\nIn the above deﬁnition, when M = | S | the Gray code is called complete. If there exists t ∈ T such that t ( c M−1 ) = c 0 the Gray code is cyclic, M is called its period, and we shall, when listing the code by its sequence of transformations, include t k M = t at the end of the list. The rate of C, denoted\nIn the context of rank modulation for ﬂash memories, the set of transformations T comprises of \u201cpush-to-the-top\u201d operations, ﬁrst used in [11], and later also in [7], [20]. We denote by t i : S n → S n the \u201cpush-to-the-top\u201d operation on index i, i.e.,\nand throughout the paper we set T = { t 2 , t 3 , . . . , t n } . We also note that, in cycle notation,\nFor ease of presentation only, we also denote by t i the \u201cpush-to-the-bottom\u201d operation on index n + 1 − i, i.e.,\nLet d : S × S → N ∪ { 0 } be a distance function inducing a metric M over S. Given a transmitted codeword c ∈ C and its received version ˜c ∈ S, we say a single error occurred if d ( c, ˜c ) = 1. We are interested in Gray codes capable of detecting single errors, which we now deﬁne.\nDeﬁnition 2. Let M be a metric over S induced by a distance measure d. A snake-in-the-box code over M and S, using transitions T, is a Gray code C over S and using T, in which for every pair of distinct elements c, c ∈ C, c = c , one has d ( c, c ) 2.\nSince throughout this paper our ambient space is S n , and the transformations we use are the \u201cpush-to-the-top\u201d operations T, we shall abbreviate our notation and call a snake-in-the-box code of size M an ( n, M, M) -snake , or an M -snake . We will be considering two metrics in the next sections: Kendall\u2019s τ- metric, K , and the ∞ -metric, with their respective K -snakes and ∞ -snakes.\nKendall\u2019s τ-metric [13], denoted K , is induced by the bubble-sort distance which measures the minimal amount of adjacent transpositions required to transform one permutation into the other. For example, the distance between the permu- tations [ 2, 1, 4, 3 ] and [ 2, 4, 3, 1 ] is 2, as\nis a shortest sequence of adjacent transpositions between the two. More formally, for α , β ∈ S n , as noted in [12],\nThe metric K was ﬁrst introduced by Kendall [13] in the study of ranking in statistics. It was observed in [12] that a bounded distance in Kendall\u2019s τ-metric models errors caused\nby bounded changes in charge-levels of cells in the ﬂash memory. Error-correcting codes for this metric were studied in [2], [12], [15].\nWe let Kendall\u2019s τ adjacency graph of order n ∈ N be the graph G n = ( V n , E n ) whose vertices are permutations on n elements (i.e., V n = S n ), and { α , β } ∈ E n if and only if d K ( α , β ) = 1. It is well known that Kendall\u2019s τ-metric is graphic [5], i.e., for every α , β ∈ S n , d K ( α , β ) equals the length of the shortest path between the two in G n .\nWe begin the construction process by restricting ourselves to Gray codes using only \u201cpush-to-the-top\u201d operations on odd indices. The following lemma provides the motivation for this restriction.\nLemma 3. A Gray code over S n using only \u201cpush-to-the-top\u201d operations on odd indices is a K -snake.\nLemma 3 saves us the need to check whether a Gray code is in fact a K -snake, at the cost of restricting the set of allowed transitions (and the size of the resulting code, although Theorems 12,13, presented below, work to mitigate this concern). In particular, if n is even, the last element cannot be moved.\nBy starting with an even permutation, and using only \u201cpush- to-the-top\u201d operations on odd indices, we get a sequence of even permutations. Thus, throughout this part, the context of the alternating group A 2n+1 is assumed, where n ∈ N.\nThe construction we are about to present is recursive in na- ture. As a base for the recursion, we note that three consecutive \u201cpush-to-the-top\u201d operations on the 3rd index of permutations in A 3 constitute a complete cyclic ( 3, 3, K) -snake:\nWe shall extend C 3 to the next order as a running example alongside the general construction below.\nNow, assume that there exists a cyclic ( 2n − 1, M 2n−1 , K) - snake, C 2n−1 , and let t k 1 , t k 2 , . . . , t k M2n\nbe the sequence of transformations generating it, where k j is odd for all j ∈ [ M 2n−1 ] . We also assume that k 1 = 2n − 1 (this requirement, while perhaps appearing arbitrary, is actually quite easily satisﬁed. Indeed, every sufﬁciently large cyclic K -snake over S 2n−1 must, w.l.o.g., satisfy it. We shall make it a point to demonstrate that this holds for our construction).\nwhere the indices are taken modulo 2n − 1, and such that we indeed have σ (i) 0 ∈ A 2n+1 , i.e., σ (i) 0 is an even permutation (one simple way of achieving this is to choose them in ascending order).\nExample 4. We recall that C 3 is generated by the operations ( t 3 , t 3 , t 3 ) , which satisfy our requirement. As suggested above,\nwe order [ 5 ] \\ { 1, 3 } in ascending order, i.e., ( a 0 , a 1 , a 2 ) = ( 2, 4, 5 ) . We deﬁne the following permutations as starting points for our construction\nand readily verify that they are all even. \t 2 We now deﬁne for all i ∈ [ 2n − 1 ] and j ∈ [ M 2n−1 ] the\ni.e., we construct cycles corresponding to a mirror view of C 2n−1 on all but the two ﬁrst elements of σ (i) 0 (which, as we recall, are ( 1, a i ) ).\nExample 5. In our running example, we deﬁne the following permutations:\nand resume our construction. \t 2 We now note the following properties of our construction:\nLemma 6. Let i, k ∈ [ 2n − 1 ] and j, l ∈ [ M 2n−1 ] . The following are equivalent:\n1) The permutations σ (i) j(2n+1) and σ (k) l(2n+1) are cyclic shifts of each other.\nhence i = k. Moreover, since the two permutations\u2019 last n − 1 elements agree, and t k 1 , t k 2 , . . . , t k M2n\ninduce a Gray code, we necessarily have j = l.\nFinally, that the last statement implies the ﬁrst is trivial. Lemma 7. For all i ∈ [ 2n − 1 ] it holds that\ninduce a cyclic code, and the claim follows directly.\nTherefore we have constructed 2n − 1 cycles comprised of cyclically non-equivalent permutations (although, at this point they are not generated by \u201cpush-to-the-top\u201d operations).\nHence, if we deﬁne for all i ∈ [ 2n − 1 ] , 0 j < M 2n−1 , and 1 < m 2n, the permutations\nOur observation from one paragraph above means that at this point we have 2n − 1 disjoint cycles, which we conve- niently denote\nwhere the permutations in bold are those from Example 5. 2 Each of the cycles of size ( 2n + 1 ) M 2n−1 , is generated\nby \u201cpush-to-the-top\u201d operations, and contains all cyclic shifts of elements present in our previous version of that cycle. We merge these cycles into a single cycle in the following theorem. Theorem 9. Given a cyclic ( 2n − 1, M 2n−1 , K) -snake using only \u201cpush-to-the-top\u201d operations on odd indices such that its ﬁrst transformation is t 2n−1 , there exists a cyclic K -snake over S 2n+1 with the same properties, whose size is\nwhere, again, the indices are taken modulo 2n − 1. Thus for all i ∈ [ 2n − 2 ] we have\npermutations. A careful observation readily shows that C 2n+1 has t 2n+1 for its ﬁrst generating transformation.\nExample 10. Our running example ends with the full con- struction of a ( 5, 45, K) -snake, C 5 , from Theorem 9. The down arrows stand for an omitted sequence of t 5 transformations. The transition from column to column uses a single t 3 transforma- tion.\nWe now turn to consider the size and rate of the constructed codes, and show that their rate asymptotically tends to 1.\nTheorem 11. The size of K -snakes constructed in Theorem 9 behaves asymptotically as\nOne observes that the codes C n+1 utilize the transformation t 2n+1 overwhelmingly more than any other. This property allows one to calculate the transformation required to advance any given permutation in the code to its successor in O ( 1 ) amortized run time. In addition, the recursive nature of Theo- rem 9 lends itself to the ranking and unranking of permutations in the code (that is, the processes of attaching to a given permutation its position in the code, and vice versa) in O ( n 2 ) run time. Methods of achieving these tasks are presented and analyzed in [22]. Together, they facilitate the use of the codes C 2n+1 in the implementation of logic memory cells, by allowing one to increase the cell\u2019s \u2018level\u2019 as well as directly write data to it (and naturally, to read written data as well).\nIn this paper we explored rank-modulation snake-in-the-box codes under Kendall\u2019s τ-metric, and presented a construction yielding codes with rates asymptotically tending to 1. Some results w.r.t. bounds on the size of such codes were also proven in [22], which can be summarized by the following two theorems:\nTheorem 12. If C is an ( n, M, K) -snake then 1) M 1 2 | S n | .\n2) M = 1 2 | S n | if and only if for all { α , β } ∈ E n it holds that α ∈ C or β ∈ C.\nTheorem 13. If an ( n, M, K) -snake C contains a \u201cpush-to-the- top\u201d operation on an even index then\nHowever, it is not presently known whether these bounds are achievable, and therefore we are unable to determine how close the codes generated by our construction come to being optimal with respect to their sizes (rather than their asymptotic rates). A computer search for cyclic codes, performed on S 5 , yielded ( 5, M, K) -snakes of maximal size M = 57 (for comparison, the construction from Theorem 9 yields a ( 5, 45, K) -snake). While an abundance of such codes were found (well over 500 nonequivalent codes), they all were in fact codes over A 5 .\nIt shall be noted that a complete (but not cyclic) ( 5, 60, K) - snake over A 5 can also be constructed by amending the code presented in Example 10. However, we do not currently know whether ( 2n + 1, (2n+1)! 2 , K) -snakes over A 2n+1 exist for every length.\nThese results, along with the bounds we showed in Theo- rems 12,13 give rise to the following conjecture: For all n ∈ N a K -snake exists over A n whose size is no less than that of every K -snake over S n .\nIn addition, [22] explores rank-modulation snake-in-the-box codes using a different metric, the ∞ -metric, which is induced by the embedding of S n in Z n . More precisely, for α , β ∈ S n one deﬁnes\nWe use the ∞ -metric to model a different kind of noise- mechanism than that modeled by Kendall\u2019s τ-metric, namely spike noise. In this model, the rank of each memory cell is assumed to have been changed by a bounded amount (see [19]). Under this metric, the authors were able to present a construction which gives rise to the following theorem:\nTheorem 14. For all 4 n ∈ N there exists an ( n, M, ∞ ) - snake of size\nAnd it was again shown that these codes have rates asymp- totically tending to 1."},"refs":[{"authors":[{"name":"H. L. Abbot"},{"name":"M. Katchalski"}],"title":{"text":"On the construction of snake in the box codes"}},{"authors":[{"name":"A. Barg"},{"name":"A. Mazumdar"}],"title":{"text":"Codes in permutations and error correction for rank modulation"}},{"authors":[{"name":"J. Brewe"},{"name":"M. Gil"}],"title":{"text":"Nonvolatile Memory Technologies with Emphasis on Flash "}},{"authors":[{"name":"F. Chierichetti"},{"name":"H. Finucane"},{"name":"Z. Liu"},{"name":"M. Mitzenmacher"}],"title":{"text":"Designing ﬂoating codes for expected performance"}},{"authors":[{"name":"M. Deza"},{"name":"H. Huang"}],"title":{"text":"Metrics on permutations, a survey"}},{"authors":[{"name":"E. En Gad"},{"name":"A. Jiang"},{"name":"J. Bruck"}],"title":{"text":"Compressed encoding for rank modulation"}},{"authors":[{"name":"E. En Gad"},{"name":"M. Langberg"},{"name":"M. Schwartz"},{"name":"J. Bruck"}],"title":{"text":"Constant-weight Gray codes for local rank modulation"}},{"authors":[{"name":"F. Gray"}],"title":{"text":"Pulse code communication"}},{"authors":[{"name":"A. Jiang"},{"name":"V. Bohossian"},{"name":"J. Bruck"}],"title":{"text":"Rewriting codes for joint information storage in ﬂash memories"}},{"authors":[{"name":"A. Jiang"},{"name":"M. Langberg"},{"name":"M. Schwartz"},{"name":"J. Bruck"}],"title":{"text":"Universal rewriting in constrained memories"}},{"authors":[{"name":"A. Jiang"},{"name":"R. Mateescu"},{"name":"M. Schwartz"},{"name":"J. Bruck"}],"title":{"text":"Rank modulation for ﬂash memories"}},{"authors":[{"name":"A. Jiang"},{"name":"M. Schwartz"},{"name":"J. Bruck"}],"title":{"text":"Correcting charge-constrained errors in the rank-modulation scheme"}},{"authors":[{"name":"M. Kendal"},{"name":"J. D. Gibbon"}],"title":{"text":"Rank Correlation Methods"}},{"authors":[{"name":"T. Kløve"},{"name":"T.-T. Lin"},{"name":"S.-C. Tsai"},{"name":"W.-G. Tzeng"}],"title":{"text":"Permutation arrays under the Chebyshev distance"}},{"authors":[{"name":"A. Mazumdar"},{"name":"A. Barg"},{"name":"G. Z´emor"}],"title":{"text":"Constructions of rank modula- tion codes"}},{"authors":[{"name":"N. Papandreou"},{"name":"H. Pozidis"},{"name":"T. Mittelholzer"},{"name":"G. F. Close"},{"name":"M. Breitwisch"},{"name":"C. Lam"},{"name":"E. Eleftheriou"}],"title":{"text":"Drift-tolerant multilevel phase-change memory"}},{"authors":[{"name":"C. D. Savage"}],"title":{"text":"A survey of combinatorial Gray codes"}},{"authors":[{"name":"R. Sedgewick"}],"title":{"text":"Permutation generation methods"}},{"authors":[{"name":"I. Tamo"},{"name":"M. Schwartz"}],"title":{"text":"Correcting limited-magnitude errors in the rank-modulation scheme"}},{"authors":[{"name":"Z. Wang"},{"name":"J. Bruck"}],"title":{"text":"Partial rank modulation for ﬂash memories"}},{"authors":[{"name":"E. Yaakobi"},{"name":"A. Vardy"},{"name":"P. H. Siegel"},{"name":"J. K. Wolf"}],"title":{"text":"Multidimensional ﬂash codes"}},{"authors":[{"name":"Y. Yehezkeally"},{"name":"M. Schwartz"}],"title":{"text":"Snake-in-the-box codes for rank modulation"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012test/1569558901.pdf"},"links":[{"id":"1569559259","weight":11},{"id":"1569559541","weight":15},{"id":"1569559221","weight":15},{"id":"1569558785","weight":22},{"id":"1569559565","weight":28},{"id":"1569558681","weight":15},{"id":"1569559195","weight":16},{"id":"1569558859","weight":76},{"id":"1569566489","weight":8},{"id":"1569559111","weight":20},{"id":"1569558985","weight":11},{"id":"1569558509","weight":14},{"id":"1569565705","weight":15},{"id":"1569551347","weight":16},{"id":"1569559199","weight":23},{"id":"1569559035","weight":5},{"id":"1569558779","weight":17},{"id":"1569559523","weight":19},{"id":"1569559597","weight":15},{"id":"1569559251","weight":17},{"id":"1569550425","weight":20},{"id":"1569564509","weight":2},{"id":"1569558697","weight":13},{"id":"1569559233","weight":13}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S17.T1.2","endtime":"15:40","authors":"Yonatan Yehezkeally, Moshe Schwartz","date":"1341588000000","papertitle":"Snake-in-the-Box Codes for Rank Modulation","starttime":"15:20","session":"S17.T1: Rank-Modulation Coding","room":"Kresge Rehearsal B (030)","paperid":"1569558901"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
