{"id":"1569565961","paper":{"title":{"text":"Secure Network Coding and Non-Malleable Codes: Protection Against Linear Tampering"},"authors":[{"name":"Herv´e Chabanne ∗\u2020\u2021"},{"name":"G´erard Cohen \u2020\u2021"},{"name":"Alain Patey ∗\u2020\u2021"}],"abstr":{"text":"Abstract\u2014At ICS 2010, Dziembowski et al. introduced the no- tion of Non-Malleable Codes (NMC), adapting the cryptographic notion of non-malleability to the coding theory. Using NMC, if an attacker modiﬁes a codeword, decoding this modiﬁed codeword will return either the original message or a completely unrelated value.\nThe property of non-malleability depends on a family of modiﬁcations authorized to the attacker. In their paper, Dziem- bowski et al. propose a construction valid for the family of all bit-wise independent functions. At ITW 2011, Chabanne et al. proposed another construction for non-malleable codes w.r.t. bit-wise independent tampering functions by drawing a parallel between NMC and the Wire-Tap Channel II.\nIn this paper, we show that the construction using Linear Coset Coding proposed by Chabanne et al. is non-malleable w.r.t. a larger class of functions, by considering linear tampering. Our results are derived from security results on Secure Network Coding using Linear Coset Coding, introduced by El Rouayheb and Soljanin at ISIT 2007.\nIndex Terms\u2014Non-Malleable Codes, Secure Network Coding, Wire-Tap Channel II, Coset Coding"},"body":{"text":"In cryptography, the non-malleability property requires that it is impossible, given a ciphertext, to produce another different ciphertext so that the corresponding plaintexts are related to each other. Recently, Dziembowski et al. [1] proposed a trans- position of the cryptographic deﬁnition of non-malleability to the ﬁeld of coding theory. NMC have then been subject of several research papers in the past two years [2]\u2013[5]. Informally, a NMC is deﬁned as a code such that, when a codeword is subject to modiﬁcations, its decoding procedure either corrects these errors and decodes to the original message or returns a value that is completely unrelated to the original message.\nThe motivation for NMC is tamperproofness. Non- malleability can indeed be useful in real-life applications. Some storage devices may be assumed to be \u201cread-proof\u201d because of a sufﬁcient amount of physical or algorithmic protections to prevent anyone from learning the data stored on them. However, even if one cannot read the data, injecting faults in the data and observing the way it affects functions using these data can help to recover them. Injecting faults can be done for instance using lasers [6]. There exists an important\nliterature on how to use Differential Fault Analysis to break cryptosystems (e.g. [7], [8]).\nThe property of non-malleability, as deﬁned in [1], is subject to a choice of a family of modiﬁcations that we allow an ad- versary to make on the codewords. Dziembowski et al. proved that it is impossible for a code to be non-malleable w.r.t. the set of all possible modiﬁcations of codewords. An important class of tampering functions, considered in [1] and [2], is the class of bit-wise independent tampering functions, i.e. modiﬁcations that affect each bit of the codeword independently: ﬂipping the bit or setting it to 0 or 1 (see Section II-B1). This is typically what can be done using fault injections and, consequently, focusing on this family of tampering functions is worthwhile. In [1], a construction for NMC w.r.t. all bit-wise independent functions is proposed but an implementable construction is left as an open problem. In [2], Chabanne et al. show that Linear Coset Coding, as used in the Wire-Tap Channel II [9] (or Wire-Tap Channel with erasures), is a way to build a NMC w.r.t. a subset of the class of bit-wise independent tampering functions. Moreover, this technique is explicitly implementable and has computationally efﬁcient encoding and decoding procedures.\nIn this paper, we deeper investigate the class of functions w.r.t. which Linear Coset Coding is non-malleable. We ﬁrst make the observation that the action of a bit-wise independent tampering function f on a codeword c ∈ {0, 1} n can be represented as f (c) = A.c + B where A is a diagonal square matrix of size n and B is a vector of size n, both with coefﬁcients in {0, 1} (cf. Figure 3). From this remark, we investigate the class of matrix-vector couples (A, B) such that the linear coset coding construction is non-malleable w.r.t. f : x → A.x + B.\nIn [10], El Rouayheb and Soljanin consider the use of Coset Coding in the Secure Network Coding (SNC) setting introduced in [11]. In a few words, in the SNC setting, a codeword is sent through a network represented as a directed acyclic graph, a linear function of the original codeword being available at each edge and it is required that a wiretapper accessing any bounded subset of these edges gains no in- formation on the original codeword. This setting generalizes, for instance, One-Time Pad, Wire-Tap Channel II and Secret Sharing (see [12] for a comprehensive study on SNC). [10] suggests to encode messages using Coset Coding and gives a\nsecurity condition on the linear combinations on the codeword spread through the network, depending on the parity-check matrix used for the Coset Coding and on the rank of these linear combinations.\nIn the following, we show that this approach for SNC can lead to a new approach for NMC but the security requirements for SNC are stronger than ours since the adversary gets codewords in the context of SNC but only decoded codewords in the context of NMC. Their analysis can however be used to deﬁne a class of linear functions w.r.t. which Linear Coset Coding is non-malleable.\nThis paper is organized as follows. In Section II, we do some recalls on the results of [1] and [2] and begin our investigation on linear tampering functions. In Section III, we consider the approach of SNC and recall some results on the security of SNC using coset coding. In Section IV, we state and prove our results on the non-malleability of Linear Coset Coding w.r.t. linear tampering functions. We ﬁnally conclude in Section V.\nIn this section, we recall the deﬁnition of NMC [1] and the results of Chabanne et al. [2] on the non-malleability of Linear Coset Coding.\nIn the following, a [n, k, d] linear code denotes a subspace of dimension k of F n 2 with minimal Hamming distance d.\nIn the following, we consider a randomized encoding func- tion Enc : {0, 1} k → {0, 1} n , which is associated to a deter- ministic decoding function Dec : {0, 1} n → {0, 1} k ∪ {⊥}, where ⊥ means that the codeword cannot be decoded. Let F 2 denote the ﬁeld with two elements.\n1) The Tampering Experiment: Let us ﬁrst introduce the situation considered in NMC. In this model, a source message m is encoded using Enc, in order to be later decoded using Dec. The codeword c = Enc(m) is stored on a device or sent over a channel before being decoded. During this phase, an attacker applies some tampering function f belonging to a given family of functions F ⊂ F n 2 F n 2 . A tampered codeword ˜ c = f (c) is thus obtained. This erroneous codeword is then decoded to ˜ m = Dec(˜ c). This process is described in Figure 1.\nNow focus on the behaviour of the attacker, called Eve in the following. Eve applies a function f ∈ F to the codeword c, but she does not read c. In the real world, this can be seen as injecting faults on a device that you cannot read (e.g. a smart- card) using, for instance, a laser. In this experiment, Eve can however read the resulting decoded message ˜ m and try to learn as much as possible about m from ˜ m. Let us also specify that f is a deterministic function and, furthermore, that Eve knows which function she has chosen in F .\n2) Deﬁnition of NMC: Let F be a family of tampering functions. For each f ∈ F , we deﬁne a random variable Tamper f m corresponding to the tampering experiment de- scribed in the previous section:\nThe randomness is induced by the encoding function Enc. The Non-Malleability property is deﬁned as follows:\nDeﬁnition 1 (Non-Malleability). Let (Enc, Dec) be a coding scheme, where Enc : {0, 1} k → {0, 1} n is random and Dec : {0, 1} n → {0, 1} k ∪ {⊥} deterministic. Let F ⊂ F n 2 F n 2 be a family of tampering functions.\nWe say that the coding scheme (Enc, Dec) is non-malleable w.r.t. F if for each f ∈ F , there exists a distribution D f over {0, 1} k ∪ {⊥, same} such that, ∀s ∈ {0, 1} k , we have:\n \n \nwhere ≈ denotes computational or statistical indistinguisha- bility.\nFirst, notice that the deﬁnition is relative to a family F of tampering functions, but the property of indistinguishability concerns each function f separately. Non-malleability w.r.t. a family is in fact non-malleability w.r.t. each function in this family.\nNow let us recall what we expect from a NMC. We want that, after the tampering experiment, either the codeword ˜ c is well-decoded to the original message m despite the tampering or the decoding procedure results in a value ˜ m that is unrelated to the original message. That is the idea behind the distribution D f : either it returns the symbol same, meaning that the decoding furnishes the original value or it returns a value ˜ m ∈ {0, 1} k ∪ {⊥}. As D f depends only on f and not on the message m, in the latter case, the value returned in the second part of Equation (1) is unrelated to m.\n3) Basic Examples and General Results: We informally give a few examples and results on NMC to illustrate the deﬁnition. Details and proofs can be found in [1].\n\u2022 Every code is non-malleable w.r.t. {id} where id is the identity function on F n 2 .\n\u2022 Error-correcting (resp. error-detecting) codes are non- malleable w.r.t. the families of tampering functions in- troducing only errors that they can correct (resp. detect).\n2 is a family of functions such that n > log(log(|F |)), then there exists a non-malleable code w.r.t. F .\n1) Bit-wise Independent Tampering: Bit-wise independent tampering is a special case of tampering where each bit of the\ncodeword is tampered with independently. Formally a function f : {0, 1} n → {0, 1} n is bit-wise independent if we can ﬁnd n independent functions f 1 , . . . , f n : {0, 1} → {0, 1} such that ∀x ∈ {0, 1} n , f (x) = (f 1 (x), . . . , f n (x)). There are four possibilities for each f i which we denote by keep, ﬂip, 0 and 1 (keep and ﬂip are explicit, 0 (resp. 1) is the function that sets a bit to 0 (resp. 1) regardless of what it was before).\nIn [1], a construction for a NMC w.r.t. the family of all bit-wise independent functions is introduced. It uses Linear Error-Correcting Secret-Sharing (LECSS) schemes [13] and Algebraic Manipulation Detection (AMD) codes [14], which are quite unusual tools. The construction is furthermore not ex- plicitly implementable. Therefore, Chabanne et al. [2], draw- ing a parallel with the Wire-Tap Channel II [9], proposed to use Linear Coset Coding as a way to achieve non-malleability w.r.t. bit-wise independent functions.\n2) Linear Coset Coding: Linear Coset Coding (LCC) is a random encoding used in particular for the Wire-Tap Channel [9], [15]. This type of encoding uses a [n, n − k, d] linear code C with a parity-check matrix H. To encode a message m ∈ F k 2 , one randomly chooses an element among all c ∈ F n 2 such that m = Hc. To decode a codeword c, one just applies the parity-check matrix H and obtains the syndrome of c for the code C, which is the message m. This procedure is summed up in Figure 2.\nGiven: C a [n, n − k, d] linear code with a k × n parity- check matrix H\nEncode: m ∈ F k 2 → R c ∈ F n 2 s.t. Hc = m Decode: c ∈ F n 2 → m = Hc\nIn the following, we only consider LCC based on maximum distance separable (MDS) codes. In the MDS case, we have necessarily d = k + 1, so we might withdraw the distance from the code notation and talk about [n, n − k] MDS codes.\n3) Non Malleability: It is proven in [2] that linear coset coding is a NMC w.r.t. bit-wise independent functions where the number of 0 and 1 is above a threshold dependent on the distance of the underlying code. We recall the main result of [2], adapted to the case of MDS codes.\nTheorem 1 ( [2]). Let F ⊂ F n 2 F n 2 be a family of bit-wise independent tampering functions such that:\nLet C be a [n, n − k] MDS linear code such that k < D. Then a LCC using C is non-malleable w.r.t. F .\n4) Towards Linear Tampering: In order to study non- malleability of LCC w.r.t. linear tampering functions, we ﬁrst study the representation of bit-wise independent functions as linear functions.\nLet f be a bit-wise independent function and let A ∈ F n×n 2 , B ∈ F n 2 be such that ∀x ∈ F n 2 , f (x) = A.x+B. A small example summing up all possibilities is drawn in Figure 3. The fact that f is a bit-wise independent function is equivalent to\nthe fact that A is a diagonal matrix. If f i =keep (resp. ﬂip) then A ii = 1 and B i = 0 (resp. 1). If f i =0 (resp. 1) then A ii = 0 and B i = 0 (resp. 1). Consequently, the condition for non-malleability stated in Theorem 1 only concerns A. More precisely, with the notations of the theorem, the condition is |{A ii |A ii = 0}| > k.\n  \n1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0\n  \n  \n0 1 0 1\n  \nWe will see in Section IV how this condition on diagonal matrices extends to all matrices via considerations on the rank. Before that, let us consider the setting of Secure Network Coding and see how it is related to our problem.\nWe give a quick overview of the results on Secure Network Coding. For more details, see [12].\nThe Secure Network or Wiretap Network Model was in- troduced in [11] by Cai and Yeung. It is an extension of the Network Model where the network is represented as a directed acyclic graph with a single source node sending a message m over the network towards user nodes, at the end of paths in the graph. The message is encoded before being sent through the network. To each edge of the graph is associated a packet depending of this codeword. In the model considered here, an intermediate node receives one or several packets and sends a linear combination of these packets through the edges that leave the node. In the SNC model, we also consider a wiretapper that can access a subset of the edges of the network and tries to recover m from the combinations of packets that he obtained. The security condition of SNC states that:\n1) The user nodes can recover the original message m from the packets that they received\n2) For any subset of edges that we allow the adversary to obtain, the adversary gets no information on m.\nUsually, a bound µ is given and the adversary can access any set of µ edges, but only one at a time, without getting information on m.\nAs an example, we represent in Figure 4 a secure butterﬂy network, where the source node s wishes to send a message m ∈ F 3 to two user nodes U 1 and U 2 . Therefore, s picks a random x 1 ∈ F 3 and sets x 2 = m−x 1 and proceeds as one can see in the ﬁgure. Notice that intermediate nodes act as follows: if they receive one edge, they transmit what they receive, if they receive two edges, they transmit a linear combination of the packets they received. It is easy to see that the user nodes can recover the message and that an adversary with access to up to µ = 1 edge learns no information on m.\nIn [10], El Rouhayeb and Soljanin suggest to use Linear Coset Coding as a way to achieve security in the SNC model. If the source node wishes to send a k-symbol message over the network, it uses Linear Coset Coding with a k×n parity-check matrix H and sends the n symbols over the network. The intermediate nodes send a predetermined linear combination of the elements they received through the edges leaving them.\nFor instance, let us consider the Secure Butterﬂy network represented in Figure 4 again. It corresponds to a SNC using LCC, where n = 1, k = 2 and H = 1 1 .\nTheorem 2 (Security of SNC using LCC). A SNC based on LCC based on a MDS code with a k × n parity-check matrix H, such that no linear combination of µ ≤ n − k packets sent over edges belongs to the space spanned by the rows of H, is secure against an adversary who can observe µ edges.\nWe see that it proves the security of the Secure Butterﬂy Network of Figure 4, since µ = 1 and the coding vectors present in the edges can be represented as (1, 0), (0, 1) and (1, 2), each of which not belonging to the space spanned by (1, 1).\nLet us give an overview of the arguments of the proof of Theorem 2, as proposed in [10]. Let us denote by S the random variable associated with the k symbols of original message, by Y the random variable associated with the n LCC symbols and by Z the random variable associated with the µ packets observed by the adversary. We should have H(S|Z) = H(S) and H(S|Y ) = 0, here H denotes the entropy function. This is translated to a condition on the matrix A whose rows are the coding vectors associated with the packets carried in the set W of edges that the adversary observes. The ﬁrst condition is rank(A)≤ n − k. When equality is achieved in the latter inequality, it implies a second condition: rank H A = n for all A such that rank(A) = n − k, which explains the condition on the rows of A and H. For a full proof, see [10] or the proof of Section IV-B, which is similar.\nWe here show that the approach of Secure Network Coding can be used to consider the non-malleability of LCC w.r.t. linear functions.\nIn the context of SNC, the user encodes a message using LCC, deﬁnes a set of linear manipulations that the intermediate nodes are allowed to operate on the codewords. The adversary gets a bounded set of linearly manipulated codewords and tries to gain information from them, but should learn nothing.\nIn the context of NMC w.r.t. linear tampering, the user encodes using LCC. The adversary is allowed to apply a set of linear manipulations on the codeword but cannot see the modiﬁed codewords. He however tries to learn information from the result of the decoding of these modiﬁed codewords.\nSo, the way that the codewords are manipulated is the same but the adversary does not observe the same thing in both settings, i.e. modiﬁed codewords in the SNC setting and modiﬁed decoded messages in the NMC setting. Given that an adversary in the SNC model can for instance decode what he observes, the SNC model is stronger, and if a combination (linear function) of codewords is allowed to be observed by the adversary in the SNC model while maintaining security, then the corresponding LCC is non-malleable w.r.t. this linear function.\nWe can see, on the example of Figure 4 that the NMC model encompasses more linear functions. For instance, let us consider the function f : x → 0 1 1 2 x. One cannot allow\n, since m = x 1 + x 2 . But in the case of the tampering experiment, one obtains ˜ m = 1 1 0 1 1 2 x 1 x\n= x 1 , which gives no information on m.\nLet us now explain how we are using the proof of Theorem 2 to ﬁnd a class of linear functions w.r.t. which LCC is non malleable. In the SNC model, the adversary observes Ac (with the notations of the tampering experiment). In the NMC model, the adversary observes HAc. If we apply the security analysis of Theorem 2 on HA instead of A, we get a non- malleability result, depending on the rank of HA and of the linear span of the rows of HA. In the SNC model, there is a bound on the number of edges observed by the adversary, which is the same as the maximal rank of A. Since the rank is the only parameter that matters to prove security, we can get rid of the condition on the number of edges (i.e. on the number of rows of A) and work with square matrices.\nWe formalize the previous analysis in the following theo- rem:\nTheorem 3 (Non-Malleability of LCC w.r.t. linear functions). Let C be a [n, n − k] MDS linear code, with a k × n parity- check matrix H.\nLet F lin ⊂ F n 2 F n 2 be a family of linear tampering functions such that ∀f : x → A.x + B ∈ F lin ,\nProof: This result is an adaptation of the analysis of [10] to the setting of the Tampering Experiment described in Section II-A.\nLet H be a parity-check matrix of a [n, n − k] MDS code and f ∈ F lin In order to simplify the proof, we consider a linear function without second member f : x → A.x. This is non restrictive, indeed, with the notations of the tampering experiment, if HAc is unrelated to m then so is HAc + HB.\nLet M = (m 1 , . . . , m k ) denote the random variable as- sociated with the k symbols of the original message, C = (c 1 , . . . , c n ) denote the random variable associated with the n symbols of the codeword (i.e. M = HC) and ˜ M = ( ˜ m 1 , . . . , ˜ m k ) denote the random variable associated with the k symbols of the result of the tampering experiment (i.e.\n˜ M = HAC). Writing H(M, C, ˜ M ) in two different forms (and removing H( ˜ M )), we get:\nThe decodability of the codeword gives H(M |C, ˜ M ) = 0. The security condition implies that H(M | ˜ M ) = H(M ). We thus obtain H(C|M, ˜ M ) = H(C| ˜ M ) − H(M ). This implies that n − rank(HA) − k ≥ 0. We consequently require that rank(HA) ≤ n − k.\nIf the latter bound is achieved, H(C|M, ˜ M ) = 0 and the system of equations\nhas to have a unique solution, then rank H HA must be n. Since rank(H) = k and rank(HA) = n − k, we obtain our condition on the spaces spanned by the rows of H and the rows of HA.\nWe can then deduce a distribution D f , which is indistin- guishable from the result of the tampering experiment. It can for instance be described as D f = HAB + HB where B is a vector of n Bernoulli(1/2) distributions. This proves that this LCC satisﬁes non-malleability w.r.t. f and, consequently, non-malleability w.r.t. F lin .\nRemark 1. For the same LCC, the class of linear functions considered in Theorem 2 is included in the class of functions considered in Theorem 3.\nBit-wise independent tampering functions, seen as linear functions (see Section II-B) considered in Theorem 1 are also included.\nRemark 2. Notice that we de do not prove the reciprocal propriety of Theorem 3. Indeed, we only aimed at considering\nlinear functions that induced decorrelation between ˜ m and m, and not those introducing errors that are corrected. For instance, LCC are non-malleable w.r.t. the functions f : x → x + c where c is a codeword of the underlying MDS code, i.e. where Hc = 0.\nIn this paper, we have extended the analysis of Linear Coset Coding as a non-malleable code. Following a security analysis close to the one of Secure Network Coding, we proved that Linear Coset Coding is non-malleable w.r.t. linear functions such that their product with the parity-check matrix of the underlying code fulﬁls conditions on rank and dimension.\nAn interesting problem is to characterize the whole class of functions w.r.t. which such codes are non-malleable."},"refs":[{"authors":[{"name":"S. Dziembowski"},{"name":"K. Pietrzak"},{"name":"D. Wichs"}],"title":{"text":"Non-malleable codes"}},{"authors":[{"name":"H. Chabanne"},{"name":"G. Cohen"},{"name":"J. Flori"},{"name":"A. Patey"}],"title":{"text":"Non-malleable codes from the wire-tap channel"}},{"authors":[{"name":"S. G. Choi"},{"name":"A. Kiayias"},{"name":"T. Malkin"}],"title":{"text":"Bitr: Built-in tamper resilience"}},{"authors":[{"name":"F.-H. Liu"},{"name":"A. Lysyanskaya"}],"title":{"text":"Tamper and leakage resilience in the split-state model"}},{"authors":[{"name":"K. Cwalina"}],"title":{"text":"Explicit construction of a non-malleable code: an analysis of a recent approach by d., k. and o."}},{"authors":[{"name":"S. P. Skorobogatov"},{"name":"R. J. Anderson"}],"title":{"text":"Optical fault induction attacks"}},{"authors":[{"name":"D. Boneh"},{"name":"R. A. DeMillo"},{"name":"R. J. Lipton"}],"title":{"text":"On the importance of checking cryptographic protocols for faults (extended abstract)"}},{"authors":[{"name":"H. Bar-El"},{"name":"H. Choukri"},{"name":"D. Naccache"},{"name":"M. Tunstall"},{"name":"C. Whelan"}],"title":{"text":"The sorcerer\u2019s apprentice guide to fault attacks"}},{"authors":[{"name":"L. H. Ozarow"},{"name":"A. D. Wyner"}],"title":{"text":"Wire-tap channel II"}},{"authors":[{"name":"S. Y. El Rouayheb"},{"name":"E. Soljanin"}],"title":{"text":"On wiretap networks ii"}},{"authors":[{"name":"N. Cai"},{"name":"R. Yeung"}],"title":{"text":"Secure network coding"}},{"authors":[{"name":"N. Cai"},{"name":"T. Chan"}],"title":{"text":"Theory of secure network coding"}},{"authors":[{"name":"H. Chen"},{"name":"R. Cramer"},{"name":"S. Goldwasser"},{"name":"R. de Haan"},{"name":"V. Vaikuntanathan"}],"title":{"text":"Secure computation from random error correcting codes"}},{"authors":[{"name":"R. Cramer"},{"name":"Y. Dodis"},{"name":"S. Fehr"},{"name":"C. Padr´o"},{"name":"D. Wichs"}],"title":{"text":"Detection of algebraic manipulation with applications to robust secret sharing and fuzzy extractors"}},{"authors":[{"name":"A. D. Wyner"}],"title":{"text":"The wire-tap channel"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565961.pdf"},"links":[{"id":"1569566567","weight":2},{"id":"1569564843","weight":3},{"id":"1569566485","weight":3},{"id":"1569565883","weight":5},{"id":"1569564889","weight":3},{"id":"1569566725","weight":8},{"id":"1569565377","weight":2},{"id":"1569566385","weight":3},{"id":"1569567049","weight":2},{"id":"1569564635","weight":2},{"id":"1569565867","weight":4},{"id":"1569566799","weight":2},{"id":"1569565067","weight":3},{"id":"1569559665","weight":4},{"id":"1569561021","weight":2},{"id":"1569564669","weight":2},{"id":"1569565691","weight":6},{"id":"1569564605","weight":3},{"id":"1569566981","weight":2},{"id":"1569566321","weight":3},{"id":"1569566605","weight":2},{"id":"1569566683","weight":4},{"id":"1569566855","weight":3},{"id":"1569566869","weight":2},{"id":"1569565097","weight":2},{"id":"1569566227","weight":2},{"id":"1569566091","weight":2},{"id":"1569559259","weight":7},{"id":"1569566697","weight":5},{"id":"1569566597","weight":6},{"id":"1569565551","weight":3},{"id":"1569565711","weight":3},{"id":"1569566761","weight":2},{"id":"1569566943","weight":5},{"id":"1569565091","weight":4},{"id":"1569566591","weight":3},{"id":"1569566571","weight":4},{"id":"1569552245","weight":5},{"id":"1569565607","weight":3},{"id":"1569565495","weight":2},{"id":"1569559967","weight":7},{"id":"1569567045","weight":5},{"id":"1569565227","weight":2},{"id":"1569564481","weight":5},{"id":"1569560833","weight":3},{"id":"1569566415","weight":4},{"id":"1569564805","weight":7},{"id":"1569567005","weight":3},{"id":"1569566081","weight":5},{"id":"1569565613","weight":2},{"id":"1569565355","weight":2},{"id":"1569565931","weight":4},{"id":"1569566647","weight":2},{"id":"1569551535","weight":3},{"id":"1569566765","weight":2},{"id":"1569564897","weight":5},{"id":"1569565775","weight":3},{"id":"1569566871","weight":5},{"id":"1569565461","weight":4},{"id":"1569564731","weight":2},{"id":"1569565171","weight":3},{"id":"1569566207","weight":7},{"id":"1569564227","weight":3},{"id":"1569558325","weight":4},{"id":"1569565837","weight":3},{"id":"1569566671","weight":3},{"id":"1569564233","weight":2},{"id":"1569566459","weight":3},{"id":"1569567535","weight":4},{"id":"1569563411","weight":3},{"id":"1569560427","weight":2},{"id":"1569564849","weight":4},{"id":"1569559541","weight":2},{"id":"1569566363","weight":2},{"id":"1569566941","weight":3},{"id":"1569566033","weight":3},{"id":"1569566739","weight":3},{"id":"1569555811","weight":2},{"id":"1569558459","weight":2},{"id":"1569565609","weight":4},{"id":"1569565291","weight":3},{"id":"1569564203","weight":3},{"id":"1569566821","weight":3},{"id":"1569556713","weight":3},{"id":"1569566467","weight":4},{"id":"1569566903","weight":3},{"id":"1569565859","weight":4},{"id":"1569565809","weight":5},{"id":"1569566843","weight":3},{"id":"1569558483","weight":3},{"id":"1569566563","weight":5},{"id":"1569566089","weight":2},{"id":"1569565347","weight":2},{"id":"1569566925","weight":5},{"id":"1569564387","weight":4},{"id":"1569565455","weight":2},{"id":"1569566497","weight":5},{"id":"1569566795","weight":5},{"id":"1569566963","weight":4},{"id":"1569561679","weight":6},{"id":"1569566709","weight":2},{"id":"1569566787","weight":2},{"id":"1569566015","weight":3},{"id":"1569565897","weight":3},{"id":"1569551763","weight":2},{"id":"1569565953","weight":2},{"id":"1569566895","weight":5},{"id":"1569566749","weight":2},{"id":"1569566269","weight":3},{"id":"1569564189","weight":3},{"id":"1569566985","weight":2},{"id":"1569564613","weight":3},{"id":"1569567009","weight":4},{"id":"1569566865","weight":2},{"id":"1569565321","weight":3},{"id":"1569558785","weight":4},{"id":"1569564647","weight":2},{"id":"1569566193","weight":7},{"id":"1569565907","weight":2},{"id":"1569566343","weight":2},{"id":"1569565803","weight":3},{"id":"1569565785","weight":3},{"id":"1569566239","weight":5},{"id":"1569566167","weight":2},{"id":"1569566679","weight":7},{"id":"1569565989","weight":4},{"id":"1569566575","weight":6},{"id":"1569563981","weight":2},{"id":"1569561085","weight":2},{"id":"1569566617","weight":2},{"id":"1569559565","weight":4},{"id":"1569566905","weight":3},{"id":"1569563307","weight":4},{"id":"1569566063","weight":3},{"id":"1569566759","weight":2},{"id":"1569565589","weight":2},{"id":"1569559195","weight":3},{"id":"1569566149","weight":2},{"id":"1569559995","weight":2},{"id":"1569566657","weight":3},{"id":"1569558859","weight":6},{"id":"1569565199","weight":3},{"id":"1569566643","weight":3},{"id":"1569566511","weight":3},{"id":"1569566719","weight":2},{"id":"1569565841","weight":9},{"id":"1569566369","weight":3},{"id":"1569566531","weight":3},{"id":"1569567665","weight":4},{"id":"1569561143","weight":3},{"id":"1569566581","weight":2},{"id":"1569565833","weight":3},{"id":"1569564611","weight":3},{"id":"1569565535","weight":3},{"id":"1569562867","weight":4},{"id":"1569566395","weight":2},{"id":"1569565667","weight":3},{"id":"1569561795","weight":2},{"id":"1569566325","weight":5},{"id":"1569566423","weight":2},{"id":"1569565257","weight":2},{"id":"1569564795","weight":6},{"id":"1569567015","weight":4},{"id":"1569559805","weight":4},{"id":"1569566437","weight":2},{"id":"1569566811","weight":2},{"id":"1569558901","weight":2},{"id":"1569565735","weight":2},{"id":"1569553909","weight":2},{"id":"1569559111","weight":3},{"id":"1569553537","weight":3},{"id":"1569565427","weight":4},{"id":"1569566403","weight":2},{"id":"1569565839","weight":2},{"id":"1569552251","weight":3},{"id":"1569566139","weight":2},{"id":"1569567051","weight":2},{"id":"1569566885","weight":3},{"id":"1569564441","weight":2},{"id":"1569566231","weight":2},{"id":"1569566513","weight":2},{"id":"1569554881","weight":2},{"id":"1569554971","weight":2},{"id":"1569565501","weight":2},{"id":"1569566445","weight":3},{"id":"1569566209","weight":3},{"id":"1569566649","weight":2},{"id":"1569565559","weight":2},{"id":"1569566371","weight":2},{"id":"1569565655","weight":5},{"id":"1569566909","weight":3},{"id":"1569566127","weight":3},{"id":"1569565151","weight":4},{"id":"1569558985","weight":3},{"id":"1569563763","weight":3},{"id":"1569565087","weight":3},{"id":"1569566473","weight":5},{"id":"1569564857","weight":6},{"id":"1569564333","weight":2},{"id":"1569566913","weight":4},{"id":"1569566809","weight":2},{"id":"1569566629","weight":2},{"id":"1569566257","weight":3},{"id":"1569565033","weight":6},{"id":"1569566447","weight":3},{"id":"1569565817","weight":3},{"id":"1569565847","weight":9},{"id":"1569563897","weight":2},{"id":"1569565887","weight":2},{"id":"1569565929","weight":2},{"id":"1569566141","weight":4},{"id":"1569565055","weight":3},{"id":"1569565633","weight":6},{"id":"1569565279","weight":4},{"id":"1569555879","weight":4},{"id":"1569566115","weight":3},{"id":"1569565219","weight":8},{"id":"1569558509","weight":2},{"id":"1569554759","weight":2},{"id":"1569565595","weight":4},{"id":"1569565185","weight":6},{"id":"1569566773","weight":4},{"id":"1569566037","weight":2},{"id":"1569564985","weight":2},{"id":"1569566223","weight":2},{"id":"1569558401","weight":2},{"id":"1569566553","weight":5},{"id":"1569564973","weight":3},{"id":"1569564969","weight":3},{"id":"1569565029","weight":4},{"id":"1569561245","weight":2},{"id":"1569566505","weight":3},{"id":"1569565393","weight":2},{"id":"1569565933","weight":8},{"id":"1569565705","weight":2},{"id":"1569566191","weight":3},{"id":"1569567033","weight":3},{"id":"1569565527","weight":4},{"id":"1569566853","weight":2},{"id":"1569566603","weight":7},{"id":"1569567029","weight":2},{"id":"1569566159","weight":3},{"id":"1569566695","weight":5},{"id":"1569566051","weight":4},{"id":"1569561379","weight":4},{"id":"1569561123","weight":7},{"id":"1569566673","weight":2},{"id":"1569565311","weight":4},{"id":"1569566233","weight":2},{"id":"1569566667","weight":2},{"id":"1569566893","weight":3},{"id":"1569566317","weight":5},{"id":"1569560997","weight":5},{"id":"1569563845","weight":2},{"id":"1569566407","weight":2},{"id":"1569560349","weight":3},{"id":"1569566501","weight":3},{"id":"1569565741","weight":4},{"id":"1569566275","weight":4},{"id":"1569566481","weight":12},{"id":"1569565545","weight":2},{"id":"1569566857","weight":2},{"id":"1569566387","weight":2},{"id":"1569566245","weight":3},{"id":"1569560503","weight":4},{"id":"1569565463","weight":3},{"id":"1569564339","weight":2},{"id":"1569566219","weight":2},{"id":"1569566229","weight":3},{"id":"1569566133","weight":4},{"id":"1569562551","weight":2},{"id":"1569563395","weight":2},{"id":"1569565415","weight":2},{"id":"1569555367","weight":2},{"id":"1569561623","weight":2},{"id":"1569564485","weight":4},{"id":"1569566631","weight":4},{"id":"1569565571","weight":10},{"id":"1569565885","weight":2},{"id":"1569566177","weight":4},{"id":"1569565493","weight":4},{"id":"1569557633","weight":2},{"id":"1569564411","weight":7},{"id":"1569566805","weight":4},{"id":"1569559199","weight":2},{"id":"1569566293","weight":3},{"id":"1569565665","weight":2},{"id":"1569565523","weight":5},{"id":"1569565611","weight":2},{"id":"1569557715","weight":5},{"id":"1569564175","weight":2},{"id":"1569566983","weight":3},{"id":"1569566779","weight":3},{"id":"1569566097","weight":3},{"id":"1569566479","weight":4},{"id":"1569556361","weight":3},{"id":"1569566431","weight":2},{"id":"1569565397","weight":2},{"id":"1569566873","weight":2},{"id":"1569565765","weight":3},{"id":"1569565925","weight":8},{"id":"1569565435","weight":2},{"id":"1569557275","weight":4},{"id":"1569565263","weight":2},{"id":"1569565215","weight":2},{"id":"1569565385","weight":4},{"id":"1569565575","weight":2},{"id":"1569565919","weight":4},{"id":"1569566711","weight":5},{"id":"1569565241","weight":4},{"id":"1569566927","weight":5},{"id":"1569565661","weight":2},{"id":"1569565865","weight":2},{"id":"1569566887","weight":5},{"id":"1569565273","weight":2},{"id":"1569564131","weight":3},{"id":"1569552037","weight":3},{"id":"1569564919","weight":3},{"id":"1569565511","weight":2},{"id":"1569566737","weight":4},{"id":"1569566429","weight":3},{"id":"1569561221","weight":2},{"id":"1569566917","weight":5},{"id":"1569566035","weight":3},{"id":"1569565353","weight":4},{"id":"1569564305","weight":4},{"id":"1569564283","weight":3},{"id":"1569564291","weight":2},{"id":"1569566691","weight":3},{"id":"1569565421","weight":2},{"id":"1569566547","weight":2},{"id":"1569566651","weight":3},{"id":"1569566823","weight":2},{"id":"1569566595","weight":2},{"id":"1569566677","weight":2},{"id":"1569565349","weight":4},{"id":"1569552025","weight":6},{"id":"1569566137","weight":3},{"id":"1569566529","weight":5},{"id":"1569565375","weight":2},{"id":"1569566715","weight":3},{"id":"1569565237","weight":3},{"id":"1569566819","weight":2},{"id":"1569565041","weight":2},{"id":"1569564703","weight":2},{"id":"1569566713","weight":2},{"id":"1569565541","weight":2},{"id":"1569566813","weight":9},{"id":"1569566771","weight":3},{"id":"1569564201","weight":3},{"id":"1569562277","weight":3},{"id":"1569566641","weight":2},{"id":"1569565425","weight":3},{"id":"1569564247","weight":2},{"id":"1569564437","weight":3},{"id":"1569566533","weight":2},{"id":"1569563975","weight":2},{"id":"1569551905","weight":3},{"id":"1569564861","weight":9},{"id":"1569565457","weight":4},{"id":"1569566487","weight":8},{"id":"1569565529","weight":4},{"id":"1569556759","weight":2},{"id":"1569566619","weight":3},{"id":"1569566075","weight":2},{"id":"1569566397","weight":2},{"id":"1569566301","weight":2},{"id":"1569558779","weight":2},{"id":"1569565233","weight":3},{"id":"1569563721","weight":2},{"id":"1569565593","weight":2},{"id":"1569560235","weight":2},{"id":"1569566817","weight":4},{"id":"1569564157","weight":2},{"id":"1569566389","weight":3},{"id":"1569566911","weight":2},{"id":"1569564923","weight":15},{"id":"1569566299","weight":3},{"id":"1569564769","weight":2},{"id":"1569565769","weight":3},{"id":"1569566601","weight":5},{"id":"1569565805","weight":3},{"id":"1569566933","weight":2},{"id":"1569563919","weight":2},{"id":"1569566577","weight":4},{"id":"1569557851","weight":2},{"id":"1569565389","weight":2},{"id":"1569559919","weight":2},{"id":"1569565861","weight":3},{"id":"1569566147","weight":5},{"id":"1569565537","weight":2},{"id":"1569560785","weight":2},{"id":"1569565561","weight":4},{"id":"1569560213","weight":4},{"id":"1569566457","weight":2},{"id":"1569565997","weight":4},{"id":"1569563425","weight":5},{"id":"1569565035","weight":8},{"id":"1569559597","weight":2},{"id":"1569564961","weight":3},{"id":"1569559251","weight":2},{"id":"1569567013","weight":5},{"id":"1569561861","weight":3},{"id":"1569565337","weight":2},{"id":"1569565737","weight":2},{"id":"1569560459","weight":4},{"id":"1569564463","weight":2},{"id":"1569565853","weight":5},{"id":"1569550425","weight":4},{"id":"1569566273","weight":3},{"id":"1569564123","weight":6},{"id":"1569565889","weight":3},{"id":"1569566635","weight":5},{"id":"1569566611","weight":2},{"id":"1569564505","weight":3},{"id":"1569565165","weight":7},{"id":"1569565565","weight":2},{"id":"1569565635","weight":3},{"id":"1569561397","weight":2},{"id":"1569565731","weight":3},{"id":"1569566797","weight":8},{"id":"1569566413","weight":3},{"id":"1569565707","weight":3},{"id":"1569566375","weight":2},{"id":"1569564257","weight":3},{"id":"1569565583","weight":3},{"id":"1569566555","weight":12},{"id":"1569564141","weight":5},{"id":"1569566973","weight":5},{"id":"1569561579","weight":3},{"id":"1569566449","weight":2},{"id":"1569565031","weight":5},{"id":"1569551541","weight":2},{"id":"1569565619","weight":2},{"id":"1569566839","weight":2},{"id":"1569551751","weight":2},{"id":"1569565139","weight":7},{"id":"1569566663","weight":3},{"id":"1569565579","weight":5},{"id":"1569566067","weight":2},{"id":"1569566825","weight":4},{"id":"1569566241","weight":3},{"id":"1569563007","weight":2},{"id":"1569566113","weight":3},{"id":"1569566443","weight":2},{"id":"1569566727","weight":6},{"id":"1569565315","weight":3},{"id":"1569566417","weight":4},{"id":"1569560581","weight":5},{"id":"1569559233","weight":2}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S14.T6.1","endtime":"17:00","authors":"Hervé Chabanne, Gerard Cohen, Alain Patey","date":"1341506400000","papertitle":"Secure Network Coding and Non-Malleable Codes: Protection Against Linear Tampering","starttime":"16:40","session":"S14.T6: Applications of Codes in Cryptography","room":"Kresge Rehearsal A (033)","paperid":"1569565961"},"cluster":{"jsonClass":"HashMap$HashTrieMap","spectral6":"3","spectral43":"28","spectral28":"27","spectral32":"11","spectral14":"5","spectral20":"14","spectral9":"8","spectral25":"16","spectral42":"41","spectral3":"1","spectral47":"23","spectral17":"2","louvain":"433","spectral36":"31","spectral39":"26","spectral10":"2","spectral15":"8","spectral33":"13","spectral5":"4","spectral21":"17","spectral44":"4","spectral26":"0","spectral40":"31","spectral8":"2","spectral11":"10","spectral4":"2","spectral37":"34","spectral48":"17","spectral22":"20","spectral23":"19","spectral12":"7","spectral50":"14","spectral19":"8","spectral34":"13","spectral45":"4","spectral7":"4","spectral49":"43","spectral38":"28","spectral24":"23","spectral13":"2","spectral31":"8","spectral29":"17","spectral35":"34","spectral30":"18","spectral41":"9","spectral27":"10","spectral18":"5","spectral46":"0","spectral2":"0","spectral16":"14"}}
