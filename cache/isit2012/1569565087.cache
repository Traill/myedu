{"id":"1569565087","paper":{"title":{"text":"Exact Scalar Minimum Storage Coordinated Regenerating Codes"},"authors":[{"name":"Nicolas Le Scouarnec"}],"abstr":{"text":"Abstract\u2014We study the exact and optimal repair of multiple failures in codes for distributed storage. More particularly, we examine the use of interference alignment to build exact scalar minimum storage coordinated regenerating codes (MSCR). We show that it is possible to build codes for the case of k = 2 and d ≥ k by aligning interferences independently but that this technique cannot be applied as soon as k ≥ 3 and d > k. Our results also apply to adaptive regenerating codes."},"body":{"text":"Codes allow distributed storage systems to tolerate failures of some devices. Yet, repairing naively by downloading and decoding the whole code induces high repair costs. Regener- ating codes reduce this cost by repairing without decoding. Optimal tradeoffs between storage and repair cost (network bandwidth) have been established both for the single failure case [1] and for the multiple failures case [2]\u2013[4] using net- work information theory. Adaptive regenerating codes, which allow the number of devices involved to differ between repairs, have been deﬁned in [2]. The two extreme points of the optimal tradeoffs are Minimum Bandwidth (MBR/MBCR), which minimizes repair cost ﬁrst, and Minimum Storage (MSR/MSCR), which minimizes storage ﬁrst as shown on Figure 1c. Codes matching these theoretical tradeoffs can be built using non-deterministic random linear network codes.\nIn this case, repairs are termed as functional repair (Fig- ure 1a) for the regenerated data is not strictly equal to the lost data. However, such non-deterministic schemes are not desirable for they (i) require homomorphic hash functions to provide basic security (integrity checking), (ii) cannot be turned into systematic codes, which offer access to data without decoding, and (iii) they can only provide probabilistic guarantees. Deterministic schemes overcome these issues by offering exact repair (i.e., during a repair, the regenerated block is equal to the lost block and not only equivalent as shown on Figure 1b). Yet, it has been shown that exact repair is strictly harder than functional repair [5], [6] , which means that the existence of functional regenerating codes does not imply that exact regenerating codes exist. Hence, an interesting question is whether the previous tradeoffs, which apply to functional repairs, can still be achieved for exact repairs. The problem of repairing exactly a single failure has been well studied [5]\u2013[9]. However, the exact repair of multiple failures remains an open question since it has been studied only for the very speciﬁc setting d = k [4], [10].\non coordinated regenerating codes [2] with exact repair. We consider the case of n, k, d > k, t > 1 for scalar constructions (i.e., β = 1) and make the following contributions:\n\u2022 In the line of exact scalar minimum storage regenerat- ing codes [5], [8], [9], we propose exact scalar mini- mum storage coordinated regenerating codes (MSCR) for n, k = 2, d ≥ k, t = n − d. This interference alignment based construction is inspired by [5], [9]. (Section III)\n\u2022 Scalar MSR codes can be repaired exactly by aligning interferences independently [5], [7]. We show that when k ≥ 3, aligning interferences independently is not sufﬁ- cient to repair exactly scalar MSCR codes. (Section IV).\nNote that these results, which correspond to the MSCR point, also apply to exact scalar adaptive regenerating codes [2].\nMost previous works have been limited to single failures ( t = 1). For multiple failures, there only exist results for the case n, k, d = k, t = n − k, a degenerated case where the repair of regenerating codes boils down to repairing, in parallel, t independent erasure correcting codes [4]. A similar construction exists for MBCR codes [10].\nThe extended version of the article [11] can be referred to for more details on the codes constructions and the related work.\nWe consider a system storing a ﬁle of M bits spread onto n devices (each storing α = M k bits) such that the ﬁle can be recovered by collecting enough data from any k devices. For repairing coordinated regenerating codes, each failed device 1 contacts d ≥ k live devices and gets β bits from each. The t failed devices coordinate by exchanging β bits. The data is then processed and α bits are stored. These studies lead to the deﬁnition of the optimal tradeoffs between storage α and repair costs γ = dβ + (t − 1)β . The values of α, β and β corresponding to MSCR and MBCR codes are recalled on Figure 1c. In this paper, we will focus on MSCR constructions for they are very close to classical erasure correcting codes and are highly related to adaptive regenerating codes.\nIn the sequel of the article, we will study the exact repair of regenerating codes when multiple failures occur. We study the non-degenerated case of d > k and use scalar codes (β = 1).\nWe adopt the following conventions: data v and codewords w are column vectors, the generator matrix G is rectangular and the encoding operation w = Gv gives a column vector.\nWe consider a system storing a ﬁle of size M = k(d−k+t) split in k = 2 blocks (a, b), each of size α = d − k + t sub-blocks. The system consists of n = d + t devices as we assume that all failed devices and all live devices take part to the repair 2 . In the sequel of the article, we consider a ﬁnite ﬁeld F q of size q and having a generator element ω.\nThe system is compounded of two devices storing the systematic part and s = n − 2 devices storing the redundancy part.\n\u2022 The second systematic device stores b = (b 1 , . . . , b α ) t . \u2022 The i-th redundancy device, i ∈ {0 . . . α − 1}, stores\nAn example for k = 2, d = 3 and t = 2 is given on Figure 3. Using the previously deﬁned code, we can state the two\nTheorem 1. Minimum storage coordinated regenerating codes can be repaired exactly (for the systematic devices) when n = d + t, k = 2 and t = 2 (i.e., multiple repairs are performed simultaneously). Similarly, adaptive regenerating codes with k = 2 can be repaired exactly.\nProof: In the sequel of this section, we show that (i) the code we deﬁne is an MDS code (i.e., the original data can be recovered from any k = 2 devices) and (ii) the two systematic devices can be repaired exactly. To repair exactly adaptive regenerating codes, we require that any single failure can be repaired, in addition to the two aforementioned properties.\nThis property is trivially satisﬁed since, when fetching data from any two devices, we get α groups of 2 equations over 2 unknowns, where each group concerns different unknowns. The i th group is about a i and b i and consist of 2 indepen- dent equations. Hence, the unknowns of each group can be recovered and the MDS property is satisﬁed.\nThe repair consists of the following steps, which map onto the process deﬁned in [2]. In this scheme, illustrated in Figure 2, we do not rely on random linear network coding but give a method for repairing exactly.\n1. Identify lost data. Given the failure of any two devices (systematic or redundancy), we perform a change of variables to transform the actual code C into a code C , in which the failed devices are the systematic ones storing a = (a 1 . . . a d ) t and b = (b 1 . . . b d ) t . Such a code is guaranteed to exist since the original code is MDS (same argument as in [5]).\n2. Prepare (Collect). Each live device that participates to the repair computes a sub-block to be sent to the ﬁrst device and a sub-block to be sent to the second device. All the sub- blocks to be sent to the ﬁrst device have the common property that the interfering information about b is aligned (i.e., the i -th live device, storing r i , use v α i as a repair vector and sends 3 v αi r i = w αi a + z α b so that the spare device receives different information about a but the same about b. To build v αi , given some arbitrary alignment vector z α and given that r i = A i a + B i b, the repair vector is v αi = z α B −1 i . Since the MDS property is satisﬁed (i.e., we can recover from a and r i ), B i is invertible, and the repair vector exists. The role of a and b are reversed for sub-blocks to be sent to the second device.\n3. Transfer (Collect). The sub-blocks are sent and the ﬁrst (resp. second) device stores them temporarily as c a = (v α1 r 1 , . . . , v αd r d ) t (resp. c b ) for use in steps 4 and 6.\n4. Prepare (Coordinate). Using what has been received in step 3, the second spare device prepares a sub-block v α0 c b = w α0 a + z α b to be sent to the ﬁrst spare device. The information about b is aligned as in sub-blocks prepared during step 2. Again, the role a and b are reversed for the sub-block to be sent from the ﬁrst to the second spare device.\n5. Transfer (Coordinate). The sub-blocks are sent and the ﬁrst (resp. second) spare devices adds them to blocks received in step 3 thus storing (c a |v α0 c b ) t (resp. (c b |v β0 c a ) t ).\n6. Recover and Store. The d + 1 sub-blocks (c a |v α0 c b ) t = (w α 1 a + z α b, . . . , w αd a + z α b, w α0 a + z α b) t allow re- covering both the interfering information z α b (but not the individual values of b i ), and the desired information a = (a 1 . . . a d ) t . Indeed, the received sub-blocks deﬁne d + 1 equations over d+1 unknowns (z α b, a 1 , . . . , a d ). The second spare device performs a similar processing with the role of a and b reversed.\nWe now apply this general method to the repair of the systematic part of the code we deﬁne, as shown on Figure 3. A ﬁnite ﬁeld of size q = n − 1 is sufﬁcient to offer the repair of the systematic devices using the previously deﬁned code. In order to repair the two systematic devices on the code we deﬁned, during the collecting step the i-th redundancy device sends (ω −(i mod α) , . . . , ω −(i+α−1 mod α) )r i to the ﬁrst device being repaired and (1 . . . 1)r i to the second device being repaired. The vectors v αi (resp. v βi ) are chosen so that z α = σ (resp. z β = σ) with σ = (1 . . . 1) (α terms). We note c a (respectively c b ) the vector of d symbols received by the device repairing a (respectively b).\nAt the coordination step, the ﬁrst systematic device sends (ω −0 + · · · + ω −(α−1) ) −1 σc a to the second one, while the second one sends (ω 0 + · · · + ω α −1 ) −1 σc b to the ﬁrst one.\nAt the end of these steps, the ﬁrst device has received α + 1 equations. Let us note µ = 1 + · · · + 1 (α terms). Since the interfering information about b i is aligned, it writes as\nAs a consequence, it consists of a system of α + 1 indepen- dent equations and α + 1 unknowns (a i s and σb). As a result, the α unknowns a i can be recovered. The second device has received something similar with the roles a and b exchanged.\nThis repair method applied to a code (n = d + t, k = 2, d > k, t = 2) (n = 5 and d = 3 on Figure 3) naturally extends to other cases such as codes n > d + t, k = 2, d > k, t = 2.\nFinally, repairing one single device is easier, and interfer- ence alignment has already been used [5], [9]. However, we need to show that the code construction we present, which supports t = 2, also supports t = 1 to get exact scalar adaptive regenerating codes. We can apply the same repair method as for repairing two devices except that there is no coordination step and the other systematic device sends directly z α b = σb during the collecting step. As a result, after the collection step, the failed device has received α + 1 equations. Since the information about b is aligned, it can be written as\nAs a consequence, it consists of a system of α + 1 inde- pendent equations and α + 1 unknowns (a i s and σb). As a result, the α unknowns a i can be recovered.\nSince the code we present has the MDS property and supports both repairs of single failures ( t = 1) and repairs of two failures ( t = 2), it implies that it is possible to design exact scalar MSCR codes and exact scalar adaptive regenerating codes when k = 2, thus leading to Theorem 1.\nIn this section, we examine whether the previous scheme, inspired by the repair of single failures [5], [9], can be applied to multiple failures when k ≥ 3. This overall section is related to [5], [7] and similarly shows that requiring exact repairs over- constrains the system and requires alignment of information that cannot be aligned to maintain the MDS property thus leading to a contradiction.\nWhen repairing a single failed systematic 4 block a, the information about the k − 1 other systematic blocks must be aligned as shown in [5]. In particular, it is required that blocks are aligned independently. Indeed, if we consider that the systematic devices send vectors v β b, v γ c. . . , and that the i-th redundancy device sends v αi a + v βi b + v γi c . . . , to the device repairing a, then colspan (v β i ) = colspan (v β ), colspan (v γi ) = colspan (v γ ). . . for all i (i.e., systematic blocks are considered independently and all the information about each interfering block received at the device performing the repair spans only one dimension).\nWe show that under this requirement, exact repair is not possible if k ≥ 3. We give a proof, and explain the meaning of this impossibility on the information ﬂow graph.\nTheorem 2. When requiring interference alignment to be applied independently for each interfering systematic device, it is not possible to repair exactly MSCR codes with k ≥ 3, t ≥ 2 , d > k in the scalar case (i.e., M = k(d − k + t) such that each device stores only d−k+t sub-blocks of size β = 1). This impossibility also applies to adaptive regenerating codes.\nProof: Since any MDS code C can be turned into a systematic code C (as explained in [5]), we base our proof on Lemma 3. Indeed, if it was possible to repair exactly MSCR codes with k ≥ 3 and t ≥ 2, it would be possible to build exact systematic MSCR codes. Moreover, if it was possible to exactly repair adaptive regenerating codes, it would be possible to derive MSCR codes by using the same repair method and restricting it to t = 2. Hence, the impossibility result extends to adaptive regenerating codes.\nLemma 3. When requiring interference alignment to be ap- plied independently on all devices, it is not possible to repair exactly systematic MSCR codes with k ≥ 3, t ≥ 2 , d > k in the scalar case ( i.e., β = 1).\nProof: Let us consider a code with k ≥ 3, t ≥ 2, d > k, n ≥ d + t and α = d − k + t. Let us assume that we want independent interference alignment (i.e., each interfering block spans only a sub-space of dimension 1).\nThe k ﬁrst devices store systematic blocks as vectors a = (a i ) 1 ≤i≤α , b = (b i ) 1 ≤i≤α , c = (c i ) 1 ≤i≤α . . . The n − k remaining devices store redundancy blocks as r j = A 1 a + B 1 b + C 1 c + . . . . Thus leading to a set-up similar to the one depicted on Figure 4.\nWe are going to prove, by contradiction, that exact repair of systematic codes in the scalar case (i.e., β = 1) is not achievable when k ≥ 3 and t ≥ 2. For the sake of clarity, our proof will describe the case of t = 2, k = 3 and d = 4 but it naturally extends to any larger value.\nAssume that it is possible to repair exactly. Hence, it is possible to repair the simultaneous failure of devices storing a and b. We consider this case and examine how exact repair constraints the system.\nFor each device being repaired, all live devices project what they store onto a single vector and send this vector to the said device being repaired. Then, the devices being repaired coordinate by exchanging a single vector (a projection of what they have received so far). Hence, the device repairing a receives, at the end of both the collecting step and the coordination step:\nTo be able to recover a, we must be able to decode the d − k + t = 3 desired unknowns of a out of the d + t − 1 = 5 equations containing a total of k(d − k + t) = 9 unknowns. The same applies for b. Hence, when aligning independently we must have,\nLet us consider the choice of vectors v γ , v α i , v β i and of matrices C i that allows exact repairs (i.e., such that constraints on ranks are satisﬁed) with coordination (i.e., k ≥ 3 and t ≥ 2):\n\u2022 During the coordination step, what is sent by the device repairing a will necessarily be collinear to v α i C i (i.e., what is stored) and to vector v γ . Let us name this vector, which is colinear to v γ , z c . According to (3), z c , and hence v γ must be colinear to all v β i C i . Hence, we have: ∀i, v α i = ν i v γ C −1 i and v β i = µ i v γ C −1 i . Note that the matrix C i is invertible to guarantee the MDS property.\nAs a result, for all i ∈ {1 . . . d}, vectors v α i and v β i are collinear since\nLet us consider the choice of matrices for B i that allows exact repairs on the device repairing a. According to (2), we\nmust have rank (B 1 v α 1 , . . . , B d v α d ) = 1, which is equivalent to:\nρ 1 v α 1 B 1 = ρ 2 v α 2 B 2 = · · · = ρ d v α d B d \t (5) Combining (4) and (5), we can deduce that\nAs a result, rank (B 1 v β 1 , . . . , B d v β d ) = 1, which is in contradiction with (3) (i.e., b can be repaired too, or rank (B 1 v β 1 , . . . , B d v β d ) ≥ d − 1). Hence, the exact repair of two failed devices when k ≥ 3 is impossible.\nThe proof naturally extends to any higher value of k and t. Hence, repairing exactly scalar (i.e., β = 1) codes with d > k, k > 2, and t > 1 is impossible when relying on independent interference alignment.\nThis impossibility means that at some point, the amount of information that goes through the information ﬂow graph [1], [2] is too low. Indeed, to ensure that the ﬁle is kept over time, all cuts between the source S and any data collector DC in a graph representing the transfer of data between devices during repairs must be greater than or equal to M [2]. However, if we consider the graph of Figure 5 and force the device storing c to send the same β bits of information (by requiring alignment) to both the device storing a and the device storing b, then the cut shown on the graph of Figure 5 has an insufﬁcient capacity.\nIn this paper, we applied independent interference alignment to minimum storage coordinated regenerating codes (MSCR) and show that this technique allows exact repair if and only if k = 2. Our results also apply to adaptive regenerating codes thus providing an interesting solution for the implementation of practical systems when k = 2.\nTo overcome the impossibility shown in this paper, several tracks can be considered: (i) considering a technique that does not align the interferences independently, (ii) building vector codes (i.e., relying on sub-packetization with β > 1 by oppo- sition to scalar codes β = 1 considered in this paper), or (iii) building minimum bandwidth coordinated regenerating codes (MBCR) (for single failure, codes exist for all parameters [8])."},"refs":[{"authors":[{"name":"A. G. Dimakis"},{"name":"P. B. Godfrey"},{"name":"Y. Wu"},{"name":"M. O. Wainwright"},{"name":"K. Ram- chandran"}],"title":{"text":"Network Coding for Distributed Storage Systems"}},{"authors":[{"name":"A. Kermarrec"},{"name":"N. Le Scouarnec"},{"name":"G. Straub"}],"title":{"text":"Repairing Multiple Failures with Coordinated and Adaptive Regenerating Codes"}},{"authors":[{"name":"Y. Hu"},{"name":"Y. Xu"},{"name":"X. Wang"},{"name":"C. Zhan"},{"name":"P. Li"}],"title":{"text":"Cooperative Recovery of Distributed Storage Systems from Multiple Losses with Network Coding"}},{"authors":[{"name":"K. W. Shum"}],"title":{"text":"Cooperative Regenerating Codes for Distributed Storage Systems"}},{"authors":[{"name":"N. B. Shah"},{"name":"K. Rashmi"},{"name":"P. V. Kumar"},{"name":"K. Ramchandran"}],"title":{"text":"Interference Alignement in Regenerating Codes for Distributed Storage: Necessity and Code Constructions"}},{"authors":[],"title":{"text":"Distributed Storage Codes with Repair-by-Transfer and Non- achievability of Interior Points on the Storage-Bandwidth Tradeoff"}},{"authors":[],"title":{"text":"Explicit Codes Minimizing Repair Bandwidth for Distributed Storage"}},{"authors":[{"name":"K. V. Rashmi"},{"name":"N. B. Shah"},{"name":"P. V. Kumar"}],"title":{"text":"Optimal Exact- Regenerating Codes for Distributed Storage at the MSR and MBR Points via a Product-Matrix Construction"}},{"authors":[{"name":"C. Suh"},{"name":"K. Ramchandran"}],"title":{"text":"Exact-Repair MDS code construction us- ing interference alignment"}},{"authors":[{"name":"K. W. Shum"},{"name":"Y. Hu"}],"title":{"text":"Exact Minimum-Repair-Bandwidth Coopera- tive Regenerating Codes for Distributed Storage Systems"}},{"authors":[{"name":"N. Le Scouarnec"}],"title":{"text":"Exact Scalar Minimum Storage Coordinated Regen- erating Codes"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565087.pdf"},"links":[{"id":"1569565383","weight":2},{"id":"1569565883","weight":2},{"id":"1569564889","weight":5},{"id":"1569566725","weight":2},{"id":"1569565663","weight":4},{"id":"1569565377","weight":3},{"id":"1569566385","weight":3},{"id":"1569565867","weight":2},{"id":"1569566799","weight":2},{"id":"1569565067","weight":3},{"id":"1569559665","weight":2},{"id":"1569566875","weight":3},{"id":"1569566321","weight":2},{"id":"1569566683","weight":2},{"id":"1569566855","weight":2},{"id":"1569566869","weight":2},{"id":"1569566091","weight":2},{"id":"1569559259","weight":3},{"id":"1569566697","weight":2},{"id":"1569565711","weight":3},{"id":"1569566571","weight":2},{"id":"1569552245","weight":3},{"id":"1569565495","weight":2},{"id":"1569564481","weight":2},{"id":"1569566415","weight":3},{"id":"1569564805","weight":6},{"id":"1569567005","weight":3},{"id":"1569566081","weight":2},{"id":"1569565613","weight":2},{"id":"1569566647","weight":2},{"id":"1569551535","weight":2},{"id":"1569566765","weight":2},{"id":"1569564897","weight":2},{"id":"1569565775","weight":3},{"id":"1569566871","weight":2},{"id":"1569566653","weight":3},{"id":"1569565461","weight":2},{"id":"1569566207","weight":4},{"id":"1569564227","weight":2},{"id":"1569558325","weight":4},{"id":"1569565837","weight":2},{"id":"1569564233","weight":2},{"id":"1569563411","weight":2},{"id":"1569564849","weight":3},{"id":"1569565317","weight":2},{"id":"1569566319","weight":4},{"id":"1569566941","weight":2},{"id":"1569558459","weight":2},{"id":"1569565609","weight":2},{"id":"1569564203","weight":2},{"id":"1569566821","weight":3},{"id":"1569556713","weight":2},{"id":"1569566467","weight":2},{"id":"1569566903","weight":3},{"id":"1569565859","weight":3},{"id":"1569565809","weight":64},{"id":"1569566843","weight":3},{"id":"1569566579","weight":2},{"id":"1569558483","weight":3},{"id":"1569566563","weight":2},{"id":"1569566089","weight":3},{"id":"1569565347","weight":2},{"id":"1569566925","weight":2},{"id":"1569564387","weight":2},{"id":"1569565455","weight":2},{"id":"1569566497","weight":2},{"id":"1569566963","weight":2},{"id":"1569561679","weight":2},{"id":"1569566709","weight":2},{"id":"1569564989","weight":2},{"id":"1569566787","weight":2},{"id":"1569566015","weight":2},{"id":"1569566895","weight":52},{"id":"1569566269","weight":2},{"id":"1569564189","weight":3},{"id":"1569567009","weight":2},{"id":"1569566865","weight":2},{"id":"1569564647","weight":2},{"id":"1569566193","weight":3},{"id":"1569564311","weight":2},{"id":"1569565785","weight":2},{"id":"1569566679","weight":17},{"id":"1569566575","weight":10},{"id":"1569561085","weight":2},{"id":"1569559565","weight":2},{"id":"1569563307","weight":3},{"id":"1569566759","weight":4},{"id":"1569566149","weight":3},{"id":"1569566657","weight":3},{"id":"1569558859","weight":7},{"id":"1569566643","weight":2},{"id":"1569566511","weight":4},{"id":"1569566531","weight":4},{"id":"1569567665","weight":2},{"id":"1569561143","weight":2},{"id":"1569565833","weight":2},{"id":"1569564611","weight":5},{"id":"1569565535","weight":2},{"id":"1569565667","weight":3},{"id":"1569566325","weight":2},{"id":"1569566423","weight":3},{"id":"1569564795","weight":2},{"id":"1569566811","weight":2},{"id":"1569553537","weight":2},{"id":"1569565427","weight":2},{"id":"1569566403","weight":2},{"id":"1569552251","weight":2},{"id":"1569567051","weight":2},{"id":"1569566885","weight":2},{"id":"1569566513","weight":2},{"id":"1569554971","weight":2},{"id":"1569566445","weight":2},{"id":"1569566209","weight":2},{"id":"1569566649","weight":6},{"id":"1569565559","weight":2},{"id":"1569566371","weight":2},{"id":"1569566127","weight":2},{"id":"1569563763","weight":5},{"id":"1569566473","weight":4},{"id":"1569564857","weight":53},{"id":"1569566913","weight":2},{"id":"1569565033","weight":4},{"id":"1569566357","weight":2},{"id":"1569565847","weight":15},{"id":"1569566141","weight":3},{"id":"1569565633","weight":2},{"id":"1569565279","weight":2},{"id":"1569555879","weight":2},{"id":"1569566115","weight":3},{"id":"1569565219","weight":2},{"id":"1569566003","weight":2},{"id":"1569565185","weight":2},{"id":"1569566553","weight":4},{"id":"1569564969","weight":2},{"id":"1569565029","weight":3},{"id":"1569565933","weight":3},{"id":"1569565705","weight":3},{"id":"1569566191","weight":3},{"id":"1569567033","weight":2},{"id":"1569565527","weight":2},{"id":"1569566159","weight":2},{"id":"1569566695","weight":2},{"id":"1569561379","weight":2},{"id":"1569561123","weight":4},{"id":"1569565441","weight":2},{"id":"1569565311","weight":2},{"id":"1569566893","weight":3},{"id":"1569566317","weight":2},{"id":"1569560997","weight":2},{"id":"1569566501","weight":2},{"id":"1569565741","weight":2},{"id":"1569566275","weight":2},{"id":"1569566481","weight":4},{"id":"1569566857","weight":5},{"id":"1569565961","weight":3},{"id":"1569566245","weight":2},{"id":"1569566229","weight":2},{"id":"1569562551","weight":2},{"id":"1569566383","weight":2},{"id":"1569566631","weight":2},{"id":"1569565571","weight":2},{"id":"1569566177","weight":3},{"id":"1569564411","weight":2},{"id":"1569565665","weight":4},{"id":"1569566831","weight":2},{"id":"1569565611","weight":2},{"id":"1569566983","weight":4},{"id":"1569566097","weight":3},{"id":"1569566479","weight":3},{"id":"1569565765","weight":2},{"id":"1569565925","weight":6},{"id":"1569565263","weight":2},{"id":"1569565385","weight":11},{"id":"1569565919","weight":2},{"id":"1569565181","weight":3},{"id":"1569566711","weight":2},{"id":"1569565241","weight":2},{"id":"1569566887","weight":59},{"id":"1569565273","weight":2},{"id":"1569564131","weight":2},{"id":"1569564919","weight":3},{"id":"1569566737","weight":2},{"id":"1569566429","weight":2},{"id":"1569566917","weight":2},{"id":"1569564305","weight":2},{"id":"1569564291","weight":2},{"id":"1569566547","weight":2},{"id":"1569566823","weight":2},{"id":"1569566677","weight":5},{"id":"1569566137","weight":2},{"id":"1569566529","weight":2},{"id":"1569565375","weight":2},{"id":"1569565041","weight":2},{"id":"1569564703","weight":2},{"id":"1569566813","weight":2},{"id":"1569565293","weight":2},{"id":"1569566771","weight":2},{"id":"1569562277","weight":2},{"id":"1569566641","weight":3},{"id":"1569565425","weight":2},{"id":"1569564437","weight":2},{"id":"1569564861","weight":21},{"id":"1569566487","weight":3},{"id":"1569565529","weight":3},{"id":"1569556759","weight":2},{"id":"1569566619","weight":2},{"id":"1569566075","weight":2},{"id":"1569565669","weight":2},{"id":"1569563721","weight":6},{"id":"1569560235","weight":3},{"id":"1569566817","weight":3},{"id":"1569564157","weight":5},{"id":"1569566389","weight":3},{"id":"1569567483","weight":2},{"id":"1569564923","weight":2},{"id":"1569566299","weight":2},{"id":"1569565039","weight":2},{"id":"1569565769","weight":2},{"id":"1569565805","weight":3},{"id":"1569563919","weight":4},{"id":"1569557851","weight":2},{"id":"1569559919","weight":2},{"id":"1569566147","weight":2},{"id":"1569565537","weight":2},{"id":"1569565561","weight":2},{"id":"1569565035","weight":2},{"id":"1569564961","weight":2},{"id":"1569567013","weight":2},{"id":"1569561861","weight":2},{"id":"1569565737","weight":3},{"id":"1569560459","weight":2},{"id":"1569565853","weight":3},{"id":"1569566273","weight":3},{"id":"1569564123","weight":3},{"id":"1569566635","weight":2},{"id":"1569566611","weight":2},{"id":"1569565565","weight":2},{"id":"1569565635","weight":2},{"id":"1569556327","weight":2},{"id":"1569566797","weight":2},{"id":"1569565113","weight":2},{"id":"1569564257","weight":3},{"id":"1569565583","weight":2},{"id":"1569565373","weight":3},{"id":"1569566973","weight":6},{"id":"1569566987","weight":3},{"id":"1569565619","weight":2},{"id":"1569566839","weight":4},{"id":"1569565139","weight":2},{"id":"1569566663","weight":4},{"id":"1569564419","weight":2},{"id":"1569565579","weight":2},{"id":"1569566067","weight":2},{"id":"1569566825","weight":2},{"id":"1569566727","weight":2},{"id":"1569560581","weight":3}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S7.T5.4","endtime":"16:00","authors":"Nicolas Le Scouarnec","date":"1341330000000","papertitle":"Exact Scalar Minimum Storage Coordinated Regenerating Codes","starttime":"15:40","session":"S7.T5: Regenerating Codes","room":"Kresge Little Theatre (035)","paperid":"1569565087"},"cluster":{"jsonClass":"HashMap$HashTrieMap","spectral6":"3","spectral43":"17","spectral28":"23","spectral32":"19","spectral14":"8","spectral20":"7","spectral9":"8","spectral25":"22","spectral42":"23","spectral3":"1","spectral47":"40","spectral17":"4","louvain":"31","spectral36":"23","spectral39":"7","spectral10":"2","spectral15":"14","spectral33":"23","spectral5":"2","spectral21":"2","spectral44":"40","spectral26":"20","spectral40":"36","spectral8":"2","spectral11":"1","spectral4":"3","spectral37":"24","spectral48":"35","spectral22":"18","spectral23":"22","spectral12":"7","spectral50":"25","spectral19":"9","spectral34":"5","spectral45":"5","spectral7":"6","spectral49":"30","spectral38":"9","spectral24":"11","spectral13":"2","spectral31":"29","spectral29":"6","spectral35":"17","spectral30":"5","spectral41":"22","spectral27":"14","spectral18":"6","spectral46":"45","spectral2":"0","spectral16":"3"}}
