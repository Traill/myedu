{"id":"1569566155","paper":{"title":{"text":"Synchrony Ampliﬁcation"},"authors":[{"name":"Ueli Maurer"},{"name":"Bj¨orn Tackmann"}],"abstr":{"text":"Abstract\u2014Various protocols in the cryptography and distributed systems literature assume some notion of time: One major (but not the only) example are \u201csynchronous\u201d models which assume that a protocol is executed in a well- deﬁned sequence of rounds with round switches that occur (almost) simultaneously at the parties. In many of the considered models, the notion of time is either implicit, or it is closely interweaved with other mechanics of the model such that formally proving even simple statements becomes a tedious task.\nIn this work, we develop an abstract formal model that captures exactly how the availability of clocks with \u201cweak\u201d synchrony guarantees can beneﬁt parties; in particular, we show how\u2014and at what cost\u2014the \u201csynchrony\u201d of clocks can be improved. Proofs in this model are simple and the statements transfer to all models that satisfy the abstraction.\nThe main contribution of this paper is not the actual statements we prove (which mostly verify folklore be- liefs), but the formal model that follows the construction paradigm of abstract cryptography and allows to state these proofs in a simple yet rigorous manner. Indeed, the paper is a step towards a treatment of synchronous cryptographic protocols in this constructive sense."},"body":{"text":"Many protocols that are used in computer networks make use of time. This may either be explicit, as for \u201ctime-out\u201d messages that are issued if some expected message is delayed for too long, or implicit, as for synchronous protocols that are executed in a sequence of \u201crounds,\u201d where the local round switches at the parties involved in the protocol execution occur (almost) simul- taneously. The usual justiﬁcation for these models is that the \u201crounds\u201d can be emulated using weakly synchronous clocks and communication channels with a known upper bound on the delay until a message is delivered.\nOne natural goal of parties that have access to weakly synchronous clocks is to improve the synchrony, poten- tially at the cost of reducing the clock speed. In the spirit of [MR11], we consider clocks as resources available to the parties and a protocol as a construction of one resource from another one. In particular, we ask which constructions can be achieved.\nThe arguably most inﬂuential paper on the effects of time on distributed systems is [Lam78]. In fact, the physical clock model introduced there is continuous but otherwise similar to the formalization we present here. The main beneﬁt of our model is the cleaner and more rigorous formalism that makes the goals and assumptions of protocols explicit and is derived from [MR11].\nThe model presented in [KLP05] extends the inter- active Turing machine (ITM) framework widely used in cryptography by extending each such ITM with an additional \u201cclock tape.\u201d The clock tapes of the individual ITMs (which encode the protocol) can be written to by the \u201cadversary,\u201d which is another ITM that captures po- tential misbehavior. While this formalism drawn from the models prevalent in the cryptographic literature makes the model very expressive, its complexity inhibits simple proofs (even for trivial statements). Also, the exact formalization prohibits statements about the termination of protocols, which is one major reason for protocols to use time.\nThe Timed Automata in [LV96], [KLSV03] extend the state-transition model of automata by continuous trajectories on the states. While this allows to capture the inﬂuence of real-time in a detailed and concrete way, it seems fair to say that it results in a fairly complex model.\nThe main contribution of this work is the rigorous and formal yet simple model. The deﬁnitions are based on ideas developed in [MR11]; clocks are considered as resources that are available to the parties, and a protocol is a construction between such resources.\nThe model developed here, however, is restricted in that it does not allow for resources being available in addition to the clocks. An extended model that is capable of also capturing reactive resources such as communication channels (while preserving the simplicity of the current model) is currently in preparation.\nFor a number n ∈ N, let [n] := {1, . . . , n}. If, for two functions f and g, we write f (·) ≥ g(·), we mean that the condition holds on the complete domain.\nBoth clocks and protocols are formalized as systems. At the highest level of abstraction, a system is an abstract object with interfaces through which it interacts with the environment and with other systems [MR11]; interfaces are labeled with elements of a label set I. Two systems are composed into a single system by connecting one interface of each system.\nWe consider the setting in which n parties have access to (weakly) synchronous clocks. We distinguish two types of systems: The ﬁrst type are n-party clocks that are resources according to [MR11] and provide one interface for each party; resources are generally denoted by upper case letters. The second type are converters that are denoted by small Greek letters and model local actions of a party. A converter provides two interfaces: one inner interface that connects to a clock and one outer interface provided to the party. If the party corresponding to interface i ∈ I accesses the resource R via the converter τ , this is denoted as τ i R.\nFor such a systems algebra, we usually require the following type of generalized associativity, which is explained in more detail in [MR11].\nDeﬁnition 1. A set of systems with compositions is composition-order independent if for any system com- posed of several systems, the order in which the systems are composed does not matter.\nA protocol for resources with I interfaces can then simply be deﬁned as a tuple of |I| converters, one converter for each party that has access to the resource.\nThis paper is based on the construction paradigm introduced in [MR11], [Mau11]: The goal of a protocol or scheme is phrased as constructing a resource with the desired behavior from one or more given ones. As the given resources and the constructed ones are objects of the same type, such a deﬁnition is predestined for protocol composition: The resources constructed by one protocol are used by another one, which induces a serial composition operation for protocols.\nDeﬁnition 2 (Construction). A construction 1 for a re- source set Ω and a constructor set Γ is a subset of Ω × Γ × Ω. A construction is often denoted as an arrow \u201c−→\u201d as follows: If (R, α, S) is in the construction, then we write R α −→ S and say that S can be constructed from R (or that S can be reduced to R) by α.\nIn this paper, the resource set Ω is the set of all clocks, and a constructor in the set Γ corresponds to a scheme or protocol executed by the parties.\nA further notion derived from [MR11] is the concept of a speciﬁcation, which technically is a set of resources and formalizes the guarantee that the parties have access to any one resource from the set. Construction notions for resources extend generically to speciﬁcations: For two speciﬁcations R, S ⊆ Ω and a constructor α ∈ Γ,\nFor protocols that make use of clocks, the absolute value of the time is not of interest. 2 Indeed, for a single isolated party, a local clock is merely a source of \u201cactivations\u201d (such as a processor\u2019s clock); a party can of course assign to each activation some label or identiﬁer. 3 In distributed systems, the main use of time is to derive information about the order of events at different locations [Lam78], and a guarantee on the synchrony of clocks states that the activations issued to different parties are ordered in a speciﬁc manner.\nThese two purposes of using clocks\u2014activations and some global ordering\u2014are captured by specifying the availability of (weakly) synchronous clocks as an n- party resource. Restricted to the local view of each party, a clock is merely an (a priori inﬁnite) sequence of activations, that is, unary outputs of the resource. The \u201cglobal\u201d guarantee of the clocks for multiple parties is described exactly by how the activations to the individual parties are interleaved.\nDeﬁnition 3 (Clock). An n-party clock is a sequence C = (C k ) k≥1 of sets with C k ⊆ [n].\nThe interpretation of a clock C is that it proceeds in steps, and in the k-th step it issues an activation at the interfaces of all parties i with i ∈ C k . The setting\nwhere |C k | > 1 corresponds to the situation where two parties obtain activations in such a way that no \u201creal- time\u201d difference can be measured between these events; they are (essentially) simultaneous. Intuitively, the global index corresponds to the most ﬁne-grained resolution that can be observed with respect to time.\nThe knowledge about the ordering of events is often not complete; the parties might only know that their clocks advance at similar speed. Such a weaker guarantee is speciﬁed by a clock speciﬁcation, a set of clocks.\nDeﬁnition 4 (Clock speciﬁcation). An n-party clock speciﬁcation is a set C of n-party clocks.\nThe local time of a party i ∈ [n] connected to a clock C = (C k ) k≥1 with respect to the global index k can, without loss of generality, be deﬁned to be the number of activations that the party obtained up to k.\nDeﬁnition 5 (Local time). The local time at the k-th index at party i ∈ [n] is deﬁned as\nThe speed of a clock is measured by its \u201crate\u201d with respect to the global index k: the number of activations issued up to k. The rate can of course be deﬁned for each individual party or for the complete clock (as the rate of the \u201cslowest\u201d party). Since we will be interested in comparing how the rates of clocks evolve over time, we consider the rate of a clock as a function of the index. Deﬁnition 6 (Rate). For a clock C and an index k ∈ N, the rate of C at party i up to index k is the value rat i C (k) := loc i C (k) k . For brevity, we deﬁne rat C (k) := min i∈[n] rat i C (k) and the asymptotic rate rat C := lim k→∞ rat C (k) (if deﬁned).\nAn important measure of the synchrony of a clock is the offset, that is, the maximum difference between the local times at two different parties.\nDeﬁnition 7 (Offset). For a clock C, the offset at index k ∈ N is deﬁned as\nFor a function δ : N → N, a clock C is called a δ- bounded offset clock if oﬀ C (·) ≤ δ(·). The speciﬁcation C off δ is deﬁned as C off δ := {C| oﬀ C (·) ≤ δ(·)}.\nBounded-offset clocks guarantee that the clocks of all parties advance at (essentially) the same speed. This is a strong assumption, which is not justiﬁable for many clocks used in practice where one might only want to make the assumption that the difference in speed is bounded; that is, the clocks have a bounded drift.\nDeﬁnition 8 (Drift). For k ∈ N, the drift of a clock C up to index k is deﬁned as\nloc i C (k) loc j C (k)\nWe set drf C (k) := 1 for all k with min i∈[n] loc i C (k) = 0. For a function ρ : N → R, a clock C is called a ρ- bounded drift clock if drf C (·) ≤ ρ(·). The speciﬁcation C drf ρ is deﬁned as C drf ρ := {C| drf C (·) ≤ ρ(·)}.\nNote that our deﬁnition of drift differs from that used, for instance, in [KLP05] in that they require that the difference in speed is bounded for every time interval. Such a notion of \u201csmoothness\u201d is stricter, but our result in Theorem 8 extends to this case.\nIf the only resources available to the parties are clocks and they cannot make use of other resources such as communication channels, then a converter that a party uses to \u201ctransform\u201d clocks can only ignore certain acti- vations and forward others. Consequently, the converter can be speciﬁed as a sequence of integers that specify the activations that are forwarded.\nDeﬁnition 9 (Converter). A (clock) converter τ is a strictly increasing (ﬁnite or inﬁnite) sequence (t l ) l≥1 of integers t l ∈ N.\nWe describe the clock that is produced by applying a converter at some interface of the original clock.\nDeﬁnition 10. Let C = (C k ) k≥1 be a clock, i be an interface of the clock, and τ = (t l ) l≥1 be a converter. The converted clock C := τ i C obtained by attaching the converter τ at the interface of party i is described by the sequence C = (C k ) k≥1 with\n(k) = t l , C k \\ {i} otherwise.\nNote that the algebra of clocks and converters fulﬁlls the notion of composition order independence from Def- inition 1. This is obvious because applying a converter at some interface i \u201ctransforms\u201d the clock in a way irrespective of what happens at the other interfaces.\nA protocol is a tuple of converters; one converter for each party.\nDeﬁnition 11. A (clock transformation) protocol is a tuple τ = (τ i ) i∈[n] of converters τ i = (t i l ) l≥1 . Applying of a protocol to a clock is deﬁned as τ C = τ 1 1 . . . τ n n C. This notion extends naturally to clock speciﬁcations.\nBy deﬁnition, a protocol can only decrease the rate of a clock (converters cannot generate activations). In prac- tical applications, one would be interested in protocols with a minimal such slackness.\nDeﬁnition 12 (Efﬁciency). Let τ be a protocol, and l ∈ N. The efﬁciency of τ at index l is deﬁned as eﬀ τ (l) := l/ max i∈[n] t i l . For ﬁnite protocols, the efﬁciency after the last deﬁned index is 0.\nSymmetric protocols in which all parties use the same converter are an important class of protocols: For constructions where both the given and the desired speciﬁcations are symmetric with respect to the parties, the interesting protocols are of this form. For this type of protocol, we show that the rate of the clocks is transformed in the expected sense.\nLemma 1. Let C be a clock and τ be a symmetric protocol, that is, τ = (τ, . . . , τ ) with τ = (t l ) l≥1 . Then,\nfor all k with ∃v ∈ N : t v = min i∈[n] loc i C (k), that is, indices at which the \u201cslowest party\u201d is activated.\nProof: By Deﬁnitions 6 and 10, rat τ C (k) = min i∈[n] loc i τ C (k) k , and loc i τ C (k) = min{l | t l ≥ loc i C (k)}. By the condition on k, rat C (k) = t v /k and eﬀ τ (v) = v/t v for v as above. By monotonicity,\nFor the indices which do not correspond to activations of τ C, we can still prove bounds for the rate.\n· loc i C (k) k . The other inequal- ity follows analogously.\nCorollary 3. Let C be a clock and τ be a symmetric protocol with constant efﬁciency, that is, eﬀ τ (·) = η ∈ (0, 1]. Then, rat τ C = η · rat C .\nA (clock transformation) protocol induces a natural notion of construction: 4 Denote by Ω the set of all clocks, and by Γ the set of all (clock transformation) protocols. Then we obtain, for C 1 , C 2 ∈ Ω and τ ∈ Γ,\nThis deﬁnition extends to clock speciﬁcations as de- scribed in Section II: For each C ∈ C 1 , the constructed τ C must be in C 2 . For speciﬁcations, however, a further notion of construction, denoted by −→, is interesting: For two speciﬁcations C 1 and C 2 , we can ask whether there is a protocol with at least efﬁciency η that con- structs C 2 from C 1 . More precisely, for C 1 , C 2 ⊆ Ω and η : N → [0, 1],\nIn order to use synchronous protocols, one needs synchronized clocks that determine the round switches. This type of synchrony is described by the speciﬁcation C sync = C off 1 , and this section describes from which type of assumption such synchrony can be achieved.\nLemma 4. Let δ 1 , δ 2 ∈ N with δ 1 ≥ δ 2 . 5 From a δ 1 - offset bounded clock C 1 , we can construct a δ 2 -offset bounded clock C 2 using a protocol τ with\nProof: We consider the symmetric protocol τ δ 1 /δ 2 in which each converter τ i is deﬁned by the (same) sequence (t l ) l≥1 with t l = (l − 1) · δ 1 /δ 2 + 1. We\nset C 2 = τ δ 1 /δ 2 C 1 . Note that this in particular means that\n(loc i C 2 (k) − 1) · δ 1 /δ 2 + 1 ≤ loc i C 1 (k) \t (1) ≤ loc i C 2 (k) · δ 1 /δ 2 ,\nwhere both (1) and (2) use Deﬁnition 10 and (1) also uses δ 1 ≥ δ 2 .\nAssume that there exists a k ∈ N with oﬀ C 2 (k) > δ 2 . This means that there exist i = j with\n(k) · δ 1 /δ 2 (4) = δ 2 · δ 1 /δ 2 = δ 1 , \t (5)\nwhere (4) follows from (1) and (2), and (5) follows from (3): loc i C 2 (k) − 1 and loc j C\n(k) have the same remainder modulo δ 2 . This equation contradicts the assumption about C 1 , and the efﬁciency statement is obvious.\nIndeed, we can prove that the rate of the clocks is transformed as expected, which follows from Lemma 2.\nLemmas 4 and 5 imply that we can obtain a round- synchronous clock from any bounded-offset clock, the rate degrades by a factor depending on the given clock.\nWe also prove a converse statement: If we only have a guarantee for the drift, the offset of the clock can grow exponentially (as a function of k). The following lemma states that one can obtain a round-synchronous clock only at the cost of a rapidly decreasing rate.\nLemma 7. Let ρ = p q ∈ Q, ρ > 1, and let τ = ((t 1 l ) l , . . . , t n l ) l ) be a protocol that achieves C drf ρ τ −→ C sync . Then, for t i v ≥ 2 · q 2 /p, t i v+2 ≥ ρ/2 · t i v .\nProof: The speciﬁcation C drf ρ contains the clock C with 2 ∈ C k for all k ∈ N and 1 ∈ C k for k = j · p/q with some j ∈ N. This clock has drf C (k) ≤ ρ.\nAssume that the protocol τ with τ 1 = (t 1 l ) l≥1 and τ 2 = (t 2 l ) l≥1 is such that τ C is synchronous. Hence, for each value t 2 v it must hold that\nthat is, party 1 switches to v + 1 before party 2 switches to v + 2. Hence, t 2 v+2 ≥ t 1 v+1 ρ for the clock C.\nOf course, using the conversely deﬁned clock C ∈ C drf ρ , we can conclude that t 1 v+1 ≥ t 2 v ρ . Plugging the two equations together, we obtain that t 2 v+2 ≥ t 2 v ρ ρ . From this, the statement for the t i v can be easily com- puted.\nBy the lemma, for a clock C with constant rate, τ C has asymptotical rate log k/k. The following theorem is a consequence of Lemma 7.\nTheorem 8. C drf ρ η −→ C sync only if η(·) vanishes expo- nentially.\nTogether, Theorems 6 and 8 imply that it is also impossible to efﬁciently construct offset-bounded clocks for any constant from an arbitrary bounded-drift clock.\nWe have developed a formal model that allows to make statements about the synchrony of clocks in a simple yet rigorous manner, which we demonstrated by proving one \u201cpositive\u201d and one \u201cnegative\u201d statement about amplifying synchrony.\nThe current model does not allow for reactive re- sources such as communication channels; a full-ﬂedged model that also covers this type of resource and can be seen as an extension of the model presented here is currently being developed. Yet, the statements proven here will be maintained."},"refs":[]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566155.pdf"},"links":[{"id":"1569564843","weight":2},{"id":"1569566527","weight":2},{"id":"1569565663","weight":3},{"id":"1569565377","weight":3},{"id":"1569564669","weight":4},{"id":"1569565097","weight":2},{"id":"1569559259","weight":2},{"id":"1569566597","weight":3},{"id":"1569566591","weight":3},{"id":"1569566571","weight":2},{"id":"1569565495","weight":3},{"id":"1569566415","weight":2},{"id":"1569564805","weight":2},{"id":"1569566081","weight":2},{"id":"1569566373","weight":6},{"id":"1569565461","weight":2},{"id":"1569566207","weight":2},{"id":"1569564233","weight":2},{"id":"1569566459","weight":2},{"id":"1569567535","weight":2},{"id":"1569564203","weight":3},{"id":"1569556713","weight":2},{"id":"1569566467","weight":3},{"id":"1569565859","weight":3},{"id":"1569566173","weight":3},{"id":"1569565347","weight":2},{"id":"1569566717","weight":2},{"id":"1569566523","weight":4},{"id":"1569566889","weight":9},{"id":"1569565785","weight":4},{"id":"1569566575","weight":2},{"id":"1569563981","weight":2},{"id":"1569559565","weight":2},{"id":"1569563307","weight":2},{"id":"1569566759","weight":2},{"id":"1569566149","weight":3},{"id":"1569566657","weight":2},{"id":"1569565365","weight":2},{"id":"1569565841","weight":3},{"id":"1569566489","weight":2},{"id":"1569565535","weight":4},{"id":"1569561795","weight":3},{"id":"1569566325","weight":2},{"id":"1569566423","weight":2},{"id":"1569564795","weight":3},{"id":"1569565427","weight":2},{"id":"1569566403","weight":4},{"id":"1569552251","weight":2},{"id":"1569566425","weight":7},{"id":"1569554971","weight":3},{"id":"1569565151","weight":8},{"id":"1569566473","weight":2},{"id":"1569566913","weight":2},{"id":"1569565847","weight":2},{"id":"1569566141","weight":3},{"id":"1569553591","weight":3},{"id":"1569566115","weight":3},{"id":"1569554759","weight":2},{"id":"1569565185","weight":2},{"id":"1569565029","weight":9},{"id":"1569562207","weight":2},{"id":"1569566191","weight":2},{"id":"1569567033","weight":2},{"id":"1569565527","weight":3},{"id":"1569566853","weight":2},{"id":"1569566603","weight":2},{"id":"1569565467","weight":2},{"id":"1569565739","weight":2},{"id":"1569566893","weight":2},{"id":"1569560997","weight":2},{"id":"1569565741","weight":2},{"id":"1569566229","weight":3},{"id":"1569566133","weight":2},{"id":"1569566383","weight":2},{"id":"1569557715","weight":2},{"id":"1569565765","weight":2},{"id":"1569565919","weight":3},{"id":"1569566711","weight":2},{"id":"1569565319","weight":2},{"id":"1569566917","weight":2},{"id":"1569565421","weight":2},{"id":"1569566823","weight":2},{"id":"1569565375","weight":2},{"id":"1569565237","weight":2},{"id":"1569565041","weight":3},{"id":"1569551905","weight":3},{"id":"1569565529","weight":2},{"id":"1569566619","weight":2},{"id":"1569561185","weight":2},{"id":"1569566075","weight":5},{"id":"1569565805","weight":2},{"id":"1569557851","weight":2},{"id":"1569565561","weight":2},{"id":"1569559251","weight":2},{"id":"1569560459","weight":9},{"id":"1569564463","weight":2},{"id":"1569565853","weight":2},{"id":"1569564123","weight":2},{"id":"1569565889","weight":2},{"id":"1569564505","weight":2},{"id":"1569565635","weight":10},{"id":"1569556327","weight":2},{"id":"1569565707","weight":2},{"id":"1569566375","weight":2},{"id":"1569566555","weight":3},{"id":"1569566973","weight":3},{"id":"1569551541","weight":2},{"id":"1569566839","weight":2},{"id":"1569565139","weight":5},{"id":"1569566663","weight":4},{"id":"1569566113","weight":2},{"id":"1569566727","weight":2},{"id":"1569565315","weight":2},{"id":"1569560581","weight":2}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S9.T6.1","endtime":"10:10","authors":"Ueli  Maurer, Björn Tackmann","date":"1341395400000","papertitle":"Synchrony Amplification","starttime":"09:50","session":"S9.T6: Synchrony and Perfect Secrecy","room":"Kresge Rehearsal A (033)","paperid":"1569566155"},"cluster":{"jsonClass":"HashMap$HashTrieMap","spectral6":"3","spectral43":"14","spectral28":"5","spectral32":"18","spectral14":"13","spectral20":"2","spectral9":"8","spectral25":"19","spectral42":"32","spectral3":"0","spectral47":"13","spectral17":"3","louvain":"559","spectral36":"21","spectral39":"26","spectral10":"2","spectral15":"8","spectral33":"4","spectral5":"4","spectral21":"20","spectral44":"32","spectral26":"16","spectral40":"38","spectral8":"2","spectral11":"10","spectral4":"2","spectral37":"30","spectral48":"38","spectral22":"20","spectral23":"19","spectral12":"7","spectral50":"17","spectral19":"8","spectral34":"32","spectral45":"22","spectral7":"5","spectral49":"7","spectral38":"6","spectral24":"22","spectral13":"1","spectral31":"0","spectral29":"17","spectral35":"31","spectral30":"1","spectral41":"38","spectral27":"4","spectral18":"5","spectral46":"0","spectral2":"0","spectral16":"14"}}
